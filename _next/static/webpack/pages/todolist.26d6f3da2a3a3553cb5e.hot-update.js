/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/todolist",{

/***/ "../../packages/core/dist/index.js":
/*!*****************************************!*\
  !*** ../../packages/core/dist/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var uuid = __webpack_require__(/*! uuid */ \"../../node_modules/uuid/dist/esm-browser/index.js\");\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction objectToMap(data) {\n  return new Map(Object.keys(data).map(function (key) {\n    return [key, data[key]];\n  }));\n}\nfunction mapToArray(map) {\n  return Array.from(map.values());\n}\nfunction arrayToObject(data) {\n  var obj = {};\n  data.forEach(function (record) {\n    return obj[record._id] = record;\n  });\n  return obj;\n}\n\nvar ChunkType;\n\n(function (ChunkType) {\n  ChunkType[\"Unknown\"] = \"\";\n  ChunkType[\"Snapshot\"] = \"snapshot\";\n  ChunkType[\"Incremental\"] = \"incremental\";\n  ChunkType[\"Update\"] = \"update\";\n  ChunkType[\"Merge\"] = \"merge\";\n  ChunkType[\"Draft\"] = \"draft\";\n  ChunkType[\"TemporaryTransaction\"] = \"temporary-transaction\";\n})(ChunkType || (ChunkType = {}));\n/**\r\n * Чанк содержит информацию об одном одновлении в одной коллекции\r\n */\n\n\nvar AbstractChunk = /*#__PURE__*/function () {\n  function AbstractChunk(data) {\n    this.id = '';\n    this.id = data.id;\n    this.parents = data.parents;\n    this.records = objectToMap(data.records);\n  }\n\n  var _proto = AbstractChunk.prototype;\n\n  _proto.toGenericChunk = function toGenericChunk() {\n    var records = {};\n    this.records.forEach(function (record, id) {\n      return records[id] = record;\n    });\n    return {\n      id: this.id,\n      type: this.type,\n      parents: this.parents.slice(),\n      records: records\n    };\n  };\n\n  return AbstractChunk;\n}();\n\nvar IncrementalChunk = /*#__PURE__*/function (_AbstractChunk) {\n  _inheritsLoose(IncrementalChunk, _AbstractChunk);\n\n  function IncrementalChunk(data) {\n    var _this;\n\n    _this = _AbstractChunk.call(this, data) || this;\n    _this.type = ChunkType.Incremental;\n    if (!_this.records.size) throw new Error(\"Incremental chunk can not be empty\");\n    return _this;\n  }\n\n  return IncrementalChunk;\n}(AbstractChunk);\n\nvar SnapshotChunk = /*#__PURE__*/function (_AbstractChunk) {\n  _inheritsLoose(SnapshotChunk, _AbstractChunk);\n\n  function SnapshotChunk(data) {\n    var _this;\n\n    _this = _AbstractChunk.call(this, data) || this;\n    _this.type = ChunkType.Snapshot;\n    return _this;\n  }\n\n  return SnapshotChunk;\n}(AbstractChunk);\n\nfunction chunkFactory(data) {\n  if (!isGenericChunk(data)) throw new Error('Invalid chunk');\n\n  switch (data.type) {\n    case ChunkType.Snapshot:\n      return new SnapshotChunk(data);\n\n    case ChunkType.TemporaryTransaction:\n    case ChunkType.Incremental:\n    default:\n      return new IncrementalChunk(data);\n  }\n}\nfunction isGenericChunk(data) {\n  if (typeof data !== 'object' || !data) return false;\n  var parents = data.parents,\n      records = data.records;\n  if (!Array.isArray(parents)) return false;\n  if (typeof records !== 'object') return false;\n  return true;\n}\n\nvar DBError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(DBError, _Error);\n\n  function DBError() {\n    return _Error.apply(this, arguments) || this;\n  }\n\n  return DBError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar SpaceNotFoundError = /*#__PURE__*/function (_DBError) {\n  _inheritsLoose(SpaceNotFoundError, _DBError);\n\n  function SpaceNotFoundError(spaceID) {\n    return _DBError.call(this, \"Space not found \\\"\" + spaceID + \"\\\"\") || this;\n  }\n\n  return SpaceNotFoundError;\n}(DBError);\n\nvar NotFoundChunkError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(NotFoundChunkError, _Error);\n\n  function NotFoundChunkError(id) {\n    return _Error.call(this, \"Chunk \\\"\" + id + \"\\\" not found in storage\") || this;\n  }\n\n  return NotFoundChunkError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ChunkStorage = /*#__PURE__*/function () {\n  function ChunkStorage(driver) {\n    this.driver = driver;\n    this.chunks = new Map();\n    this.spaces = new Map();\n  }\n\n  var _proto = ChunkStorage.prototype;\n\n  _proto.getExists = function getExists(id) {\n    return this.chunks.get(id) || null;\n  };\n\n  _proto.saveChunk = function saveChunk(chunk) {\n    try {\n      var _this2 = this;\n\n      _this2.chunks.set(chunk.id, chunk);\n\n      return Promise.resolve(_this2.driver.saveChunk(chunk.toGenericChunk())).then(function () {\n        return chunk;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.loadChunk = function loadChunk(id) {\n    try {\n      var _this4 = this;\n\n      if (!id) throw new NotFoundChunkError(id);\n      if (_this4.chunks.has(id)) return Promise.resolve(_this4.chunks.get(id));\n      return Promise.resolve(_this4.driver.loadChunk(id)).then(function (genericChunk) {\n        var chunk = chunkFactory(genericChunk);\n\n        _this4.chunks.set(chunk.id, chunk);\n\n        return chunk;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.saveSpace = function saveSpace(space) {\n    this.spaces.set(space.id, space);\n    return this.driver.saveSpace(space);\n  };\n\n  _proto.loadSpace = function loadSpace(id) {\n    try {\n      var _this6 = this;\n\n      return Promise.resolve(_this6.driver.loadSpace(id)).then(function (space) {\n        if (!space) throw new DBError(\"Space \\\"\" + id + \"\\\" not found\");\n        return space;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return ChunkStorage;\n}();\n\n/**\r\n * Предоставляет возможность получения данных по конкретному запросу\r\n */\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    var observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nvar _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    var result = new _Pact();\n    var state = this.s;\n\n    if (state) {\n      var callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        var value = _this.v;\n\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n}\n\nfunction _for(test, update, body) {\n  var stage;\n\n  for (;;) {\n    var shouldContinue = test();\n\n    if (_isSettledPact(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n\n    if (shouldContinue.then) {\n      stage = 0;\n      break;\n    }\n\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact(result)) {\n        result = result.s;\n      } else {\n        stage = 1;\n        break;\n      }\n    }\n\n    if (update) {\n      var updateValue = update();\n\n      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n        stage = 2;\n        break;\n      }\n    }\n  }\n\n  var pact = new _Pact();\n\n  var reject = _settle.bind(null, pact, 2);\n\n  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    do {\n      if (update) {\n        updateValue = update();\n\n        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n          updateValue.then(_resumeAfterUpdate).then(void 0, reject);\n          return;\n        }\n      }\n\n      shouldContinue = test();\n\n      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {\n        _settle(pact, 1, result);\n\n        return;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (_isSettledPact(result)) {\n        result = result.v;\n      }\n    } while (!result || !result.then);\n\n    result.then(_resumeAfterBody).then(void 0, reject);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      result = body();\n\n      if (result && result.then) {\n        result.then(_resumeAfterBody).then(void 0, reject);\n      } else {\n        _resumeAfterBody(result);\n      }\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n\n  function _resumeAfterUpdate() {\n    if (shouldContinue = test()) {\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n      } else {\n        _resumeAfterTest(shouldContinue);\n      }\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n}\n\nvar Cursor = /*#__PURE__*/function () {\n  function Cursor(querySelector) {\n    this.querySelector = querySelector;\n    this._done = false;\n  }\n\n  var _proto = Cursor.prototype;\n\n  // public async next(): Promise<T> {\n  //\n  // }\n  // public nextChunk(): Promise<{ chunkID: ChunkID, records: T[] }>;\n  _proto.one = function one() {\n    try {\n      var _this2 = this;\n\n      var _temp3 = function _temp3() {\n        _this2._done = true;\n        return record;\n      };\n\n      var record = null;\n\n      var _temp4 = _for(function () {\n        return !_this2.querySelector.done || !record;\n      }, void 0, function () {\n        return Promise.resolve(_this2.querySelector.next()).then(function (_ref) {\n          var records = _ref.records;\n          record = records[0] || null;\n        });\n      });\n\n      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.all = function all() {\n    try {\n      var _this4 = this;\n\n      var _temp7 = function _temp7() {\n        _this4._done = true;\n        return allRecords;\n      };\n\n      if (_this4._done) throw new Error('Cursor already complete');\n      var allRecords = [];\n\n      var _temp8 = _for(function () {\n        return !_this4.querySelector.done;\n      }, void 0, function () {\n        return Promise.resolve(_this4.querySelector.next()).then(function (_ref2) {\n          var records = _ref2.records;\n          allRecords.push.apply(allRecords, records);\n        });\n      });\n\n      return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.reduce = function reduce(reducer, initialValue) {\n    try {\n      var _this6 = this;\n\n      var _temp11 = function _temp11() {\n        _this6._done = true;\n        return _result;\n      };\n\n      if (_this6._done) throw new Error('Cursor already complete');\n      var _result = initialValue;\n\n      var _temp12 = _for(function () {\n        return !_this6.querySelector.done;\n      }, void 0, function () {\n        return Promise.resolve(_this6.querySelector.next()).then(function (_ref3) {\n          var records = _ref3.records;\n          records.forEach(function (record) {\n            return _result = reducer(_result, record);\n          });\n        });\n      });\n\n      return Promise.resolve(_temp12 && _temp12.then ? _temp12.then(_temp11) : _temp11(_temp12));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _createClass(Cursor, [{\n    key: \"done\",\n    get: function get() {\n      return this._done;\n    }\n  }]);\n\n  return Cursor;\n}();\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t  path: basedir,\n\t  exports: {},\n\t  require: function (path, base) {\n      return commonjsRequire();\n    }\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  var runtime = function (exports) {\n\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n\n    try {\n      // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n      define({}, \"\");\n    } catch (err) {\n      define = function define(obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n\n    IteratorPrototype[iteratorSymbol] = function () {\n      return this;\n    };\n\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        define(prototype, method, function (arg) {\n          return this._invoke(method, arg);\n        });\n      });\n    }\n\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return PromiseImpl.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n      return this;\n    };\n\n    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0) PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    Gp[iteratorSymbol] = function () {\n      return this;\n    };\n\n    Gp.toString = function () {\n      return \"[object Generator]\";\n    };\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    exports.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined$1;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    exports.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function reset(skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function stop() {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function dispatchException(exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function abrupt(type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function complete(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function finish(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function _catch(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n\n        return ContinueSentinel;\n      }\n    }; // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n\n    return exports;\n  }( // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   module.exports );\n\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n});\n\nfunction getFieldByPath(path) {\n  var pathArray = Array.isArray(path) ? path : path.split('.');\n  return function (obj) {\n    var tmp = obj;\n\n    for (var i = 0; i < pathArray.length; i++) {\n      if (typeof tmp !== 'object' || !tmp) return undefined;\n      var field = pathArray[i];\n      if (field in tmp) tmp = tmp[field];else return undefined;\n    }\n\n    return tmp;\n  };\n}\n\n/**\r\n * Доступные операторы\r\n * https://docs.mongodb.com/manual/reference/operator/query/\r\n */\n\nvar QueryOperators = {\n  $eq: function $eq(condition) {\n    return function (value) {\n      return value === condition;\n    };\n  },\n  $gt: function $gt(condition) {\n    return function (value) {\n      return value > condition;\n    };\n  },\n  $gte: function $gte(condition) {\n    return function (value) {\n      return value >= condition;\n    };\n  },\n  $lt: function $lt(condition) {\n    return function (value) {\n      return value < condition;\n    };\n  },\n  $lte: function $lte(condition) {\n    return function (value) {\n      return value <= condition;\n    };\n  }\n};\nfunction buildQuery(query) {\n  if (typeof query !== 'object') throw new Error('ConditionValidator must be an object');\n  var byFields = Object.keys(query).map(function (path) {\n    var getter = getFieldByPath(path);\n    var conditions = makeConditionChecker(query[path]);\n    return {\n      getter: getter,\n      conditions: conditions\n    };\n  });\n  return function (record) {\n    return byFields.every(function (_ref) {\n      var getter = _ref.getter,\n          conditions = _ref.conditions;\n      var value = getter(record);\n      return conditions.every(function (condition) {\n        return condition(value);\n      });\n    });\n  };\n}\n\nfunction makeConditionChecker(rule) {\n  var condition = typeof rule === 'object' ? rule : {\n    $eq: rule\n  };\n  return Object.keys(condition).map(function (attr) {\n    var operator = attr;\n    if (!(operator in QueryOperators)) throw new InvalidQueryError(\"Unknown operator \\\"\" + operator + \"\\\"\");\n    return QueryOperators[operator](condition[operator]);\n  });\n}\n\nvar InvalidQueryError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(InvalidQueryError, _Error);\n\n  function InvalidQueryError(message, path, query) {\n    var _this;\n\n    _this = _Error.call(this, message) || this;\n    _this.path = path;\n    _this.query = query;\n    return _this;\n  }\n\n  return InvalidQueryError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar callSymbol = Symbol('Call');\nfunction call(action) {\n  var _ref;\n\n  return _ref = {}, _ref[callSymbol] = true, _ref.action = action, _ref.args = [].slice.call(arguments, 1), _ref;\n}\nfunction isCall(value) {\n  return value && !!value[callSymbol];\n}\n\nvar getChunk = function getChunk(chunkID) {\n  try {\n    var _this2 = this;\n\n    return Promise.resolve(_this2.storage.loadChunk(chunkID)).then(function (chunk) {\n      if (!chunk) throw new NotFoundChunkError(chunkID);\n      return chunk;\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar _marked = /*#__PURE__*/regeneratorRuntime.mark(findBruteForce);\nfunction findBruteForce(headChunkID, query) {\n  var map, builtQuery, chunk, chunkID, records;\n  return regeneratorRuntime.wrap(function findBruteForce$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (query === void 0) {\n            query = {};\n          }\n\n          map = new Map();\n          builtQuery = buildQuery(query);\n          chunkID = headChunkID;\n\n        case 4:\n\n          _context.next = 7;\n          return call(getChunk, chunkID);\n\n        case 7:\n          chunk = _context.sent;\n\n          if (chunk) {\n            _context.next = 10;\n            break;\n          }\n\n          throw new NotFoundChunkError(chunkID);\n\n        case 10:\n          records = mapToArray(chunk.records).filter(isNew(map, builtQuery));\n          _context.t0 = chunk.type;\n          _context.next = _context.t0 === ChunkType.Snapshot ? 14 : _context.t0 === ChunkType.TemporaryTransaction ? 16 : _context.t0 === ChunkType.Incremental ? 16 : 20;\n          break;\n\n        case 14:\n          return _context.abrupt(\"return\", {\n            chunkID: chunkID,\n            records: records\n          });\n\n        case 16:\n          _context.next = 18;\n          return {\n            chunkID: chunkID,\n            records: records\n          };\n\n        case 18:\n          chunkID = chunk.parents[0];\n          return _context.abrupt(\"break\", 21);\n\n        case 20:\n          throw new Error(\"Unsupported chunk type \\\"\" + chunk.type + \"\\\"\");\n\n        case 21:\n          _context.next = 4;\n          break;\n\n        case 23:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction isNew(map, filter) {\n  return function (record) {\n    if (map.has(record._id)) return false;\n    if (!filter(record)) return false;\n    map.set(record._id, record);\n    return true;\n  };\n}\n\n/**\r\n * Отвечает за создание выборки для конкретного пространства данных по конкретному запросу\r\n */\n\nvar QuerySelector = /*#__PURE__*/function () {\n  function QuerySelector(db, chunkID, query) {\n    this.db = db;\n    this.chunkID = chunkID;\n    this.query = query;\n    this._done = false;\n    this.scenario = this.db.run(findBruteForce(this.chunkID, this.query));\n  }\n\n  var _proto = QuerySelector.prototype;\n\n  _proto.next = function next() {\n    try {\n      var _this2 = this;\n\n      return Promise.resolve(_this2.scenario.next()).then(function (_ref) {\n        var done = _ref.done,\n            value = _ref.value;\n        _this2._done = !!done;\n        return value;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _createClass(QuerySelector, [{\n    key: \"done\",\n    get: function get() {\n      return this._done;\n    }\n  }]);\n\n  return QuerySelector;\n}();\n\n/**\r\n * Создание и донастройка запроса к БД\r\n */\n\nvar Query = /*#__PURE__*/function () {\n  function Query(db, chunkID, query) {\n    this.db = db;\n    this.chunkID = chunkID;\n    this._query = query;\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.exec = function exec() {\n    var querySelector = new QuerySelector(this.db, this.chunkID, this._query);\n    return new Cursor(querySelector);\n  };\n\n  return Query;\n}();\n\n/**\r\n * Доступ к данным конкретной коллекции и пространства\r\n */\n\nvar SpaceReader = /*#__PURE__*/function () {\n  function SpaceReader(db, refs, config) {\n    this.db = db;\n    this.refs = refs;\n    this.config = config;\n    if (!refs) throw new Error(\"Refs can not be null\");\n  }\n\n  var _proto = SpaceReader.prototype;\n\n  _proto.find = function find(query) {\n    var chunkID = this.refs[this.config.name];\n    if (!chunkID) throw new Error(\"Invalid ref \\\"\" + this.refs[this.config.name] + \"\\\" for \" + this.config.name);\n    return new Query(this.db, chunkID, query);\n  };\n\n  _proto.findOne = function findOne(query) {\n    try {\n      var _this2 = this;\n\n      return Promise.resolve(_this2.findAll(query)).then(function (records) {\n        return records[0] || null;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.findAll = function findAll(query) {\n    return this.find(query).exec().all();\n  };\n\n  return SpaceReader;\n}();\n\nvar TemporaryTransactionChunk = /*#__PURE__*/function (_AbstractChunk) {\n  _inheritsLoose(TemporaryTransactionChunk, _AbstractChunk);\n\n  function TemporaryTransactionChunk(id, parent, records) {\n    var _this;\n\n    if (records === void 0) {\n      records = [];\n    }\n\n    _this = _AbstractChunk.call(this, {\n      id: id,\n      type: ChunkType.TemporaryTransaction,\n      parents: parent ? [parent] : [],\n      records: arrayToObject(records)\n    }) || this;\n    _this.type = ChunkType.TemporaryTransaction;\n    _this.records = new Map();\n    return _this;\n  }\n\n  return TemporaryTransactionChunk;\n}(AbstractChunk);\n\nvar Accessor = /*#__PURE__*/function () {\n  function Accessor(db, space) {\n    this.db = db;\n    this.space = space;\n    this.updatedRefs = {};\n    this.stats = {\n      deleted: [],\n      inserted: [],\n      updated: [],\n      upserted: []\n    };\n    this.chunks = {};\n  }\n\n  var _proto = Accessor.prototype;\n\n  _proto.getDB = function getDB() {\n    return this.db;\n  };\n\n  _proto.getSpace = function getSpace() {\n    return this.space;\n  };\n\n  _proto.getStats = function getStats() {\n    return this.stats;\n  };\n\n  _proto.collection = function collection(name) {\n    return new SpaceReader(this.db, this.refs, this.db.collections[name].config);\n  };\n\n  _proto.insert = function insert(collection, record) {\n    try {\n      var _this2 = this;\n\n      _this2.writeIntoCollection(collection);\n\n      if (!record._id) record = _extends({}, record, {\n        _id: uuid.v4()\n      });\n\n      _this2.chunks[collection].records.set(record._id, record);\n\n      _this2.stats.inserted.push(record._id);\n\n      _this2.stats.upserted.push(record._id);\n\n      _this2.db.storage.saveChunk(_this2.chunks[collection]);\n\n      return Promise.resolve(record);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.upsert = function upsert(collection, record) {\n    try {\n      var _this4 = this;\n\n      _this4.writeIntoCollection(collection);\n\n      if (!_this4.chunks[collection].records.has(record._id)) _this4.stats.upserted.push(record._id);\n\n      _this4.chunks[collection].records.set(record._id, record);\n\n      _this4.db.storage.saveChunk(_this4.chunks[collection]);\n\n      return Promise.resolve(record);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.writeIntoCollection = function writeIntoCollection(collection) {\n    if (collection in this.updatedRefs) return;\n    var chunkID = uuid.v4();\n    var chunk = new TemporaryTransactionChunk(chunkID, this.refs[collection]);\n    this.updatedRefs[collection] = chunkID;\n    this.chunks[collection] = chunk;\n  };\n\n  _createClass(Accessor, [{\n    key: \"refs\",\n    get: function get() {\n      return _extends({}, this.space.refs, this.updatedRefs);\n    }\n  }]);\n\n  return Accessor;\n}();\n\n/**\r\n * Представляет собой доступ к настройкам и данным коллекции\r\n */\n\nvar Collection = /*#__PURE__*/function () {\n  function Collection(db, name, config) {\n    this.db = db;\n    this.name = name;\n    this.config = config;\n  }\n\n  var _proto = Collection.prototype;\n\n  _proto.space = function space(_space) {\n    var spaceInstance = this.db.spaces.get(_space); // console.log(this.db.spaces)\n\n    if (!spaceInstance) throw new Error(\"Invalid space \\\"\" + _space + \"\\\"\");\n    return new SpaceReader(this.db, spaceInstance.refs, this.config);\n  };\n\n  return Collection;\n}();\n\n(function (Priority) {\n  Priority[Priority[\"Low\"] = 1] = \"Low\";\n  Priority[Priority[\"Normal\"] = 2] = \"Normal\";\n  Priority[Priority[\"High\"] = 3] = \"High\";\n})(exports.Priority || (exports.Priority = {}));\n\nvar CollectionConfig = function CollectionConfig(name, config) {\n  this.name = name;\n  this.indexedFields = [];\n  this.priority = exports.Priority.Normal;\n  this.indexedFields = config.indexedFields || this.indexedFields;\n  this.priority = config.priority || this.priority;\n  if ('factory' in config) this.factory = config.factory;else if ('constructor' in config) this.factory = function (data) {\n    return new config.constructor(data);\n  };else throw new Error('Invalid collection config');\n};\n\nvar Space = function Space(config) {\n  this.id = config.id;\n  this.name = config.name;\n  this.description = config.description || '';\n  this.refs = config.refs;\n};\n\nvar _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nfunction _settle$1(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact$1) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle$1.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle$1.bind(null, pact, state), _settle$1.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    var observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nvar _Pact$1 = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    var result = new _Pact();\n    var state = this.s;\n\n    if (state) {\n      var callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle$1(result, 1, callback(this.v));\n        } catch (e) {\n          _settle$1(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        var value = _this.v;\n\n        if (_this.s & 1) {\n          _settle$1(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle$1(result, 1, onRejected(value));\n        } else {\n          _settle$1(result, 2, value);\n        }\n      } catch (e) {\n        _settle$1(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact$1(thenable) {\n  return thenable instanceof _Pact$1 && thenable.s & 1;\n}\n\nfunction _forTo(array, body, check) {\n  var i = -1,\n      pact,\n      reject;\n\n  function _cycle(result) {\n    try {\n      while (++i < array.length && (!check || !check())) {\n        result = body(i);\n\n        if (result && result.then) {\n          if (_isSettledPact$1(result)) {\n            result = result.v;\n          } else {\n            result.then(_cycle, reject || (reject = _settle$1.bind(null, pact = new _Pact$1(), 2)));\n            return;\n          }\n        }\n      }\n\n      if (pact) {\n        _settle$1(pact, 1, result);\n      } else {\n        pact = result;\n      }\n    } catch (e) {\n      _settle$1(pact || (pact = new _Pact$1()), 2, e);\n    }\n  }\n\n  _cycle();\n\n  return pact;\n}\n\nfunction _forOf(target, body, check) {\n  if (typeof target[_iteratorSymbol] === \"function\") {\n    var _cycle = function _cycle(result) {\n      try {\n        while (!(step = iterator.next()).done && (!check || !check())) {\n          result = body(step.value);\n\n          if (result && result.then) {\n            if (_isSettledPact$1(result)) {\n              result = result.v;\n            } else {\n              result.then(_cycle, reject || (reject = _settle$1.bind(null, pact = new _Pact$1(), 2)));\n              return;\n            }\n          }\n        }\n\n        if (pact) {\n          _settle$1(pact, 1, result);\n        } else {\n          pact = result;\n        }\n      } catch (e) {\n        _settle$1(pact || (pact = new _Pact$1()), 2, e);\n      }\n    };\n\n    var iterator = target[_iteratorSymbol](),\n        step,\n        pact,\n        reject;\n\n    _cycle();\n\n    if (iterator[\"return\"]) {\n      var _fixup = function _fixup(value) {\n        try {\n          if (!step.done) {\n            iterator[\"return\"]();\n          }\n        } catch (e) {}\n\n        return value;\n      };\n\n      if (pact && pact.then) {\n        return pact.then(_fixup, function (e) {\n          throw _fixup(e);\n        });\n      }\n\n      _fixup();\n    }\n\n    return pact;\n  } // No support for Symbol.iterator\n\n\n  // No support for Symbol.iterator\n  if (!(\"length\" in target)) {\n    throw new TypeError(\"Object is not iterable\");\n  } // Handle live collections properly\n\n\n  // Handle live collections properly\n  var values = [];\n\n  for (var i = 0; i < target.length; i++) {\n    values.push(target[i]);\n  }\n\n  return _forTo(values, function (i) {\n    return body(values[i]);\n  }, check);\n}\n\nfunction _for$1(test, update, body) {\n  var stage;\n\n  for (;;) {\n    var shouldContinue = test();\n\n    if (_isSettledPact$1(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n\n    if (shouldContinue.then) {\n      stage = 0;\n      break;\n    }\n\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact$1(result)) {\n        result = result.s;\n      } else {\n        stage = 1;\n        break;\n      }\n    }\n\n    if (update) {\n      var updateValue = update();\n\n      if (updateValue && updateValue.then && !_isSettledPact$1(updateValue)) {\n        stage = 2;\n        break;\n      }\n    }\n  }\n\n  var pact = new _Pact$1();\n\n  var reject = _settle$1.bind(null, pact, 2);\n\n  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    do {\n      if (update) {\n        updateValue = update();\n\n        if (updateValue && updateValue.then && !_isSettledPact$1(updateValue)) {\n          updateValue.then(_resumeAfterUpdate).then(void 0, reject);\n          return;\n        }\n      }\n\n      shouldContinue = test();\n\n      if (!shouldContinue || _isSettledPact$1(shouldContinue) && !shouldContinue.v) {\n        _settle$1(pact, 1, result);\n\n        return;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (_isSettledPact$1(result)) {\n        result = result.v;\n      }\n    } while (!result || !result.then);\n\n    result.then(_resumeAfterBody).then(void 0, reject);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      result = body();\n\n      if (result && result.then) {\n        result.then(_resumeAfterBody).then(void 0, reject);\n      } else {\n        _resumeAfterBody(result);\n      }\n    } else {\n      _settle$1(pact, 1, result);\n    }\n  }\n\n  function _resumeAfterUpdate() {\n    if (shouldContinue = test()) {\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n      } else {\n        _resumeAfterTest(shouldContinue);\n      }\n    } else {\n      _settle$1(pact, 1, result);\n    }\n  }\n}\n\nvar ChunkDB = /*#__PURE__*/function () {\n  function ChunkDB(config) {\n    var _this = this;\n\n    this.spaces = new Map();\n    this.ready = false;\n    this.activeTransactions = [];\n    this.storeSubscriptions = [];\n    this.spaceSubscriptions = new Map();\n    this.collections = {};\n    Object.entries(config.collections).forEach(function (_ref) {\n      var name = _ref[0],\n          cfg = _ref[1];\n      _this.collections[name] = new Collection(_this, name, new CollectionConfig(name, cfg));\n    });\n    this.storageDriver = config.storage;\n    this.storage = new ChunkStorage(this.storageDriver);\n    var promises = [];\n    if (config.spaces) config.spaces.forEach(function (spaceID) {\n      _this.spaces.set(spaceID, {\n        id: spaceID,\n        description: '',\n        name: '',\n        refs: {}\n      });\n\n      promises.push(_this.storage.loadSpace(spaceID).then(function (data) {\n        return _this.spaces.set(spaceID, new Space(data));\n      }).then(function () {\n        return undefined;\n      }));\n    });\n    this.ready$ = Promise.all(promises).then(function () {\n      _this.ready = true;\n    });\n  }\n\n  var _proto = ChunkDB.prototype;\n\n  _proto.subscribe = function subscribe(spaceID, cb) {\n    var _this2 = this;\n\n    if (typeof spaceID === 'function') {\n      this.storeSubscriptions.push(spaceID);\n      return function () {\n        return _this2.storeSubscriptions = _this2.storeSubscriptions.filter(function (item) {\n          return item !== spaceID;\n        });\n      };\n    }\n\n    var list = this.spaceSubscriptions.get(spaceID) || [];\n    list.push(cb);\n    this.spaceSubscriptions.set(spaceID, list);\n    return function () {\n      return _this2.spaceSubscriptions.set(spaceID, list.filter(function (item) {\n        return item !== cb;\n      }));\n    };\n  };\n\n  _proto.collection = function collection(name) {\n    if (name in this.collections) return this.collections[name];\n    throw new Error(\"Invalid collection \\\"\" + name + \"\\\"\");\n  };\n\n  _proto.run = function run(scenario) {\n    var context = {\n      storage: this.storage,\n      activeTransactions: this.activeTransactions,\n      updateSpaceRefs: this.updateSpaceRefs,\n      spaces: this.spaces\n    };\n    return scenarioRunner(context, scenario); // const gen = scenario.apply(context, args);\n    //\n    // let result: any;\n    //\n    // while (true) {\n    //     const { done, value } = gen.next(result);\n    //     if (done)\n    //         return value as T;\n    //\n    //     const [action, ...callArgs] = value;\n    //\n    //     result = await action.apply(context, callArgs);\n    // }\n  };\n\n  _proto.transaction = function transaction(spaceID, maybeConfig, maybeTransaction) {\n    try {\n      var _this4 = this;\n\n      var space = _this4.spaces.get(spaceID);\n\n      if (!space) throw new SpaceNotFoundError(spaceID);\n      var transaction;\n      var config = {\n        restartOnFail: false\n      };\n\n      if (maybeTransaction) {\n        transaction = maybeTransaction;\n        Object.assign(config, maybeConfig);\n      } else {\n        transaction = maybeConfig;\n      }\n\n      var accessor = new Accessor(_this4, space);\n      return Promise.resolve(transaction(accessor)).then(function () {\n        _this4.updateSpaceRefs(spaceID, accessor.refs); // const gen = this.run(this.applyTransaction(accessor));\n        // console.log(gen);\n        // const result = await gen.next();\n        // console.log(result);\n        // if (!result.done)\n        //     throw new InnerDBError('Scenario applyTransaction must return only ones');\n\n\n        return accessor.getStats();\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getFlatChain = function getFlatChain(head, maxDepth) {\n    if (maxDepth === void 0) {\n      maxDepth = 3;\n    }\n\n    try {\n      var _this6 = this;\n\n      if (!maxDepth || !head) return Promise.resolve([]);\n      var chain = [];\n      var lastChunksIds = [head];\n      var _depth = 0;\n\n      var _temp4 = _for$1(function () {\n        return _depth < maxDepth && !!lastChunksIds.length;\n      }, function () {\n        return _depth++;\n      }, function () {\n        function _temp2() {\n          lastChunksIds = chunksIds;\n        }\n\n        var chunksIds = [];\n\n        var _temp = _forOf(lastChunksIds, function (chunkId) {\n          return Promise.resolve(_this6.storage.loadChunk(chunkId)).then(function (chunk) {\n            chain.push(chunk);\n            chunksIds.push.apply(chunksIds, chunk.parents);\n          });\n        });\n\n        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n      });\n\n      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function () {\n        return chain;\n      }) : chain);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.updateSpaceRefs = function updateSpaceRefs(spaceID, refs) {\n    try {\n      var _this8 = this;\n\n      _this8.spaces.set(spaceID, _extends({}, _this8.spaces.get(spaceID), {\n        refs: refs\n      }));\n\n      return Promise.resolve(_this8.storage.saveSpace(_this8.spaces.get(spaceID))).then(function () {\n        var subscribers = _this8.spaceSubscriptions.get(spaceID);\n\n        if (subscribers) subscribers.forEach(function (cb) {\n          return cb();\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return ChunkDB;\n}();\n\nfunction scenarioRunner(context, scenario) {\n  var next = function next(result) {\n    try {\n      var _exit2;\n\n      return Promise.resolve(_for$1(function () {\n        return !_exit2;\n      }, void 0, function () {\n        var tmp = scenario.next(result);\n        var done = !!tmp.done;\n        var value = tmp.value;\n        return function () {\n          if (isCall(value)) {\n            var action = value.action,\n                args = value.args;\n            return Promise.resolve(action.apply(context, args)).then(function (_action$apply) {\n              result = _action$apply;\n\n              if (done) {\n                _exit2 = 1;\n                return {\n                  done: done,\n                  value: result\n                };\n              }\n            });\n          } else {\n            _exit2 = 1;\n            return {\n              done: done,\n              value: value\n            };\n          }\n        }();\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return {\n    next: next\n  };\n}\n\nvar InMemoryChunkStorage = /*#__PURE__*/function () {\n  function InMemoryChunkStorage() {\n    this.chunks = new Map();\n    this.spaces = new Map();\n  } // chunks\n\n\n  var _proto = InMemoryChunkStorage.prototype;\n\n  _proto.loadChunk = function loadChunk(id) {\n    try {\n      var _this2 = this;\n\n      if (_this2.chunks.has(id)) return Promise.resolve(_this2.chunks.get(id));else throw new NotFoundChunkError(id);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.saveChunk = function saveChunk(chunk) {\n    try {\n      var _this4 = this;\n\n      _this4.chunks.set(chunk.id, chunk);\n\n      return Promise.resolve(chunk);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.markDraftChunkAsUnused = function markDraftChunkAsUnused(id) {\n    try {\n      var _this6 = this;\n\n      _this6.chunks[\"delete\"](id);\n\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.setChunks = function setChunks(chunks) {\n    var _this7 = this;\n\n    chunks.forEach(function (chunk) {\n      return _this7.chunks.set(chunk.id, chunk);\n    });\n  };\n\n  _proto.clearChunks = function clearChunks() {\n    try {\n      var _this9 = this;\n\n      _this9.chunks.clear();\n\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.reset = function reset(chunks) {\n    this.chunks.clear();\n    this.setChunks(chunks);\n  };\n\n  _proto.removeChunk = function removeChunk(id) {\n    try {\n      var _this11 = this;\n\n      _this11.chunks[\"delete\"](id);\n\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  } // spaces\n  ;\n\n  _proto.createSpace = function createSpace(space) {\n    try {\n      var _this13 = this;\n\n      if (_this13.spaces.has(space.id)) throw new DBError(\"Can not create space \\\"\" + space.id + \"\\\": already exists\");\n\n      _this13.spaces.set(space.id, space);\n\n      return Promise.resolve(space);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.loadSpace = function loadSpace(id) {\n    try {\n      var _this15 = this;\n\n      return Promise.resolve(_this15.spaces.get(id));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.saveSpace = function saveSpace(space) {\n    try {\n      var _this17 = this;\n\n      _this17.spaces.set(space.id, space);\n\n      return Promise.resolve(space);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.updateSpace = function updateSpace(id, refs) {\n    try {\n      var _this19 = this;\n\n      var space = _this19.spaces.get(id);\n\n      if (!space) throw new DBError(\"Can not update space \\\"\" + id + \"\\\": not exists\");\n\n      _this19.spaces.set(id, _extends({}, space, {\n        refs: refs\n      }));\n\n      return Promise.resolve(space);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.clearSpaces = function clearSpaces() {\n    try {\n      var _this21 = this;\n\n      _this21.spaces.clear();\n\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getAllSpaces = function getAllSpaces() {\n    try {\n      var _this23 = this;\n\n      return Promise.resolve(Array.from(_this23.spaces.values()));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return InMemoryChunkStorage;\n}();\n\nexports.ChunkDB = ChunkDB;\nexports.CollectionConfig = CollectionConfig;\nexports.InMemoryChunkStorage = InMemoryChunkStorage;\nexports.Space = Space;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL2NvcmUvZGlzdC9pbmRleC5qcz9hOWYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQywrREFBTTs7QUFFekI7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7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O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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LE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQStFO0FBQy9FLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGVBQWU7QUFDZix3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCLGFBQWE7QUFDYiIsImZpbGUiOiIuLi8uLi9wYWNrYWdlcy9jb3JlL2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb01hcChkYXRhKSB7XG4gIHJldHVybiBuZXcgTWFwKE9iamVjdC5rZXlzKGRhdGEpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIFtrZXksIGRhdGFba2V5XV07XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG1hcC52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiBhcnJheVRvT2JqZWN0KGRhdGEpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgIHJldHVybiBvYmpbcmVjb3JkLl9pZF0gPSByZWNvcmQ7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG52YXIgQ2h1bmtUeXBlO1xuXG4oZnVuY3Rpb24gKENodW5rVHlwZSkge1xuICBDaHVua1R5cGVbXCJVbmtub3duXCJdID0gXCJcIjtcbiAgQ2h1bmtUeXBlW1wiU25hcHNob3RcIl0gPSBcInNuYXBzaG90XCI7XG4gIENodW5rVHlwZVtcIkluY3JlbWVudGFsXCJdID0gXCJpbmNyZW1lbnRhbFwiO1xuICBDaHVua1R5cGVbXCJVcGRhdGVcIl0gPSBcInVwZGF0ZVwiO1xuICBDaHVua1R5cGVbXCJNZXJnZVwiXSA9IFwibWVyZ2VcIjtcbiAgQ2h1bmtUeXBlW1wiRHJhZnRcIl0gPSBcImRyYWZ0XCI7XG4gIENodW5rVHlwZVtcIlRlbXBvcmFyeVRyYW5zYWN0aW9uXCJdID0gXCJ0ZW1wb3JhcnktdHJhbnNhY3Rpb25cIjtcbn0pKENodW5rVHlwZSB8fCAoQ2h1bmtUeXBlID0ge30pKTtcbi8qKlxyXG4gKiDQp9Cw0L3QuiDRgdC+0LTQtdGA0LbQuNGCINC40L3RhNC+0YDQvNCw0YbQuNGOINC+0LEg0L7QtNC90L7QvCDQvtC00L3QvtCy0LvQtdC90LjQuCDQsiDQvtC00L3QvtC5INC60L7Qu9C70LXQutGG0LjQuFxyXG4gKi9cblxuXG52YXIgQWJzdHJhY3RDaHVuayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0Q2h1bmsoZGF0YSkge1xuICAgIHRoaXMuaWQgPSAnJztcbiAgICB0aGlzLmlkID0gZGF0YS5pZDtcbiAgICB0aGlzLnBhcmVudHMgPSBkYXRhLnBhcmVudHM7XG4gICAgdGhpcy5yZWNvcmRzID0gb2JqZWN0VG9NYXAoZGF0YS5yZWNvcmRzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBYnN0cmFjdENodW5rLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9HZW5lcmljQ2h1bmsgPSBmdW5jdGlvbiB0b0dlbmVyaWNDaHVuaygpIHtcbiAgICB2YXIgcmVjb3JkcyA9IHt9O1xuICAgIHRoaXMucmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQsIGlkKSB7XG4gICAgICByZXR1cm4gcmVjb3Jkc1tpZF0gPSByZWNvcmQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgcGFyZW50czogdGhpcy5wYXJlbnRzLnNsaWNlKCksXG4gICAgICByZWNvcmRzOiByZWNvcmRzXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQWJzdHJhY3RDaHVuaztcbn0oKTtcblxudmFyIEluY3JlbWVudGFsQ2h1bmsgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdENodW5rKSB7XG4gIF9pbmhlcml0c0xvb3NlKEluY3JlbWVudGFsQ2h1bmssIF9BYnN0cmFjdENodW5rKTtcblxuICBmdW5jdGlvbiBJbmNyZW1lbnRhbENodW5rKGRhdGEpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9BYnN0cmFjdENodW5rLmNhbGwodGhpcywgZGF0YSkgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQ2h1bmtUeXBlLkluY3JlbWVudGFsO1xuICAgIGlmICghX3RoaXMucmVjb3Jkcy5zaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJJbmNyZW1lbnRhbCBjaHVuayBjYW4gbm90IGJlIGVtcHR5XCIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbmNyZW1lbnRhbENodW5rO1xufShBYnN0cmFjdENodW5rKTtcblxudmFyIFNuYXBzaG90Q2h1bmsgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdENodW5rKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNuYXBzaG90Q2h1bmssIF9BYnN0cmFjdENodW5rKTtcblxuICBmdW5jdGlvbiBTbmFwc2hvdENodW5rKGRhdGEpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9BYnN0cmFjdENodW5rLmNhbGwodGhpcywgZGF0YSkgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQ2h1bmtUeXBlLlNuYXBzaG90O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBTbmFwc2hvdENodW5rO1xufShBYnN0cmFjdENodW5rKTtcblxuZnVuY3Rpb24gY2h1bmtGYWN0b3J5KGRhdGEpIHtcbiAgaWYgKCFpc0dlbmVyaWNDaHVuayhkYXRhKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNodW5rJyk7XG5cbiAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICBjYXNlIENodW5rVHlwZS5TbmFwc2hvdDpcbiAgICAgIHJldHVybiBuZXcgU25hcHNob3RDaHVuayhkYXRhKTtcblxuICAgIGNhc2UgQ2h1bmtUeXBlLlRlbXBvcmFyeVRyYW5zYWN0aW9uOlxuICAgIGNhc2UgQ2h1bmtUeXBlLkluY3JlbWVudGFsOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IEluY3JlbWVudGFsQ2h1bmsoZGF0YSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzR2VuZXJpY0NodW5rKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCAhZGF0YSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgcGFyZW50cyA9IGRhdGEucGFyZW50cyxcbiAgICAgIHJlY29yZHMgPSBkYXRhLnJlY29yZHM7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJlbnRzKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHJlY29yZHMgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgREJFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKERCRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gREJFcnJvcigpIHtcbiAgICByZXR1cm4gX0Vycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBEQkVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbnZhciBTcGFjZU5vdEZvdW5kRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EQkVycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNwYWNlTm90Rm91bmRFcnJvciwgX0RCRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFNwYWNlTm90Rm91bmRFcnJvcihzcGFjZUlEKSB7XG4gICAgcmV0dXJuIF9EQkVycm9yLmNhbGwodGhpcywgXCJTcGFjZSBub3QgZm91bmQgXFxcIlwiICsgc3BhY2VJRCArIFwiXFxcIlwiKSB8fCB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNwYWNlTm90Rm91bmRFcnJvcjtcbn0oREJFcnJvcik7XG5cbnZhciBOb3RGb3VuZENodW5rRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShOb3RGb3VuZENodW5rRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gTm90Rm91bmRDaHVua0Vycm9yKGlkKSB7XG4gICAgcmV0dXJuIF9FcnJvci5jYWxsKHRoaXMsIFwiQ2h1bmsgXFxcIlwiICsgaWQgKyBcIlxcXCIgbm90IGZvdW5kIGluIHN0b3JhZ2VcIikgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBOb3RGb3VuZENodW5rRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG52YXIgQ2h1bmtTdG9yYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2h1bmtTdG9yYWdlKGRyaXZlcikge1xuICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyO1xuICAgIHRoaXMuY2h1bmtzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3BhY2VzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENodW5rU3RvcmFnZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldEV4aXN0cyA9IGZ1bmN0aW9uIGdldEV4aXN0cyhpZCkge1xuICAgIHJldHVybiB0aGlzLmNodW5rcy5nZXQoaWQpIHx8IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLnNhdmVDaHVuayA9IGZ1bmN0aW9uIHNhdmVDaHVuayhjaHVuaykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgX3RoaXMyLmNodW5rcy5zZXQoY2h1bmsuaWQsIGNodW5rKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGhpczIuZHJpdmVyLnNhdmVDaHVuayhjaHVuay50b0dlbmVyaWNDaHVuaygpKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRDaHVuayA9IGZ1bmN0aW9uIGxvYWRDaHVuayhpZCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKCFpZCkgdGhyb3cgbmV3IE5vdEZvdW5kQ2h1bmtFcnJvcihpZCk7XG4gICAgICBpZiAoX3RoaXM0LmNodW5rcy5oYXMoaWQpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90aGlzNC5jaHVua3MuZ2V0KGlkKSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90aGlzNC5kcml2ZXIubG9hZENodW5rKGlkKSkudGhlbihmdW5jdGlvbiAoZ2VuZXJpY0NodW5rKSB7XG4gICAgICAgIHZhciBjaHVuayA9IGNodW5rRmFjdG9yeShnZW5lcmljQ2h1bmspO1xuXG4gICAgICAgIF90aGlzNC5jaHVua3Muc2V0KGNodW5rLmlkLCBjaHVuayk7XG5cbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2F2ZVNwYWNlID0gZnVuY3Rpb24gc2F2ZVNwYWNlKHNwYWNlKSB7XG4gICAgdGhpcy5zcGFjZXMuc2V0KHNwYWNlLmlkLCBzcGFjZSk7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyLnNhdmVTcGFjZShzcGFjZSk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRTcGFjZSA9IGZ1bmN0aW9uIGxvYWRTcGFjZShpZCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGhpczYuZHJpdmVyLmxvYWRTcGFjZShpZCkpLnRoZW4oZnVuY3Rpb24gKHNwYWNlKSB7XG4gICAgICAgIGlmICghc3BhY2UpIHRocm93IG5ldyBEQkVycm9yKFwiU3BhY2UgXFxcIlwiICsgaWQgKyBcIlxcXCIgbm90IGZvdW5kXCIpO1xuICAgICAgICByZXR1cm4gc3BhY2U7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDaHVua1N0b3JhZ2U7XG59KCk7XG5cbi8qKlxyXG4gKiDQn9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXRgiDQstC+0LfQvNC+0LbQvdC+0YHRgtGMINC/0L7Qu9GD0YfQtdC90LjRjyDQtNCw0L3QvdGL0YUg0L/QviDQutC+0L3QutGA0LXRgtC90L7QvNGDINC30LDQv9GA0L7RgdGDXHJcbiAqL1xuZnVuY3Rpb24gX3NldHRsZShwYWN0LCBzdGF0ZSwgdmFsdWUpIHtcbiAgaWYgKCFwYWN0LnMpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfUGFjdCkge1xuICAgICAgaWYgKHZhbHVlLnMpIHtcbiAgICAgICAgaWYgKHN0YXRlICYgMSkge1xuICAgICAgICAgIHN0YXRlID0gdmFsdWUucztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUudjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLm8gPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgc3RhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnRoZW4pIHtcbiAgICAgIHZhbHVlLnRoZW4oX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIHN0YXRlKSwgX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIDIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYWN0LnMgPSBzdGF0ZTtcbiAgICBwYWN0LnYgPSB2YWx1ZTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBwYWN0Lm87XG5cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyKHBhY3QpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgX1BhY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfUGFjdCgpIHt9XG5cbiAgX1BhY3QucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IF9QYWN0KCk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBzdGF0ZSAmIDEgPyBvbkZ1bGZpbGxlZCA6IG9uUmVqZWN0ZWQ7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9zZXR0bGUocmVzdWx0LCAxLCBjYWxsYmFjayh0aGlzLnYpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF9zZXR0bGUocmVzdWx0LCAyLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm8gPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLnY7XG5cbiAgICAgICAgaWYgKF90aGlzLnMgJiAxKSB7XG4gICAgICAgICAgX3NldHRsZShyZXN1bHQsIDEsIG9uRnVsZmlsbGVkID8gb25GdWxmaWxsZWQodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICBfc2V0dGxlKHJlc3VsdCwgMSwgb25SZWplY3RlZCh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zZXR0bGUocmVzdWx0LCAyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX3NldHRsZShyZXN1bHQsIDIsIGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBfUGFjdDtcbn0oKTtcblxuZnVuY3Rpb24gX2lzU2V0dGxlZFBhY3QodGhlbmFibGUpIHtcbiAgcmV0dXJuIHRoZW5hYmxlIGluc3RhbmNlb2YgX1BhY3QgJiYgdGhlbmFibGUucyAmIDE7XG59XG5cbmZ1bmN0aW9uIF9mb3IodGVzdCwgdXBkYXRlLCBib2R5KSB7XG4gIHZhciBzdGFnZTtcblxuICBmb3IgKDs7KSB7XG4gICAgdmFyIHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXG4gICAgaWYgKF9pc1NldHRsZWRQYWN0KHNob3VsZENvbnRpbnVlKSkge1xuICAgICAgc2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuICAgIH1cblxuICAgIGlmICghc2hvdWxkQ29udGludWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZENvbnRpbnVlLnRoZW4pIHtcbiAgICAgIHN0YWdlID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBib2R5KCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG4gICAgICBpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWdlID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdmFyIHVwZGF0ZVZhbHVlID0gdXBkYXRlKCk7XG5cbiAgICAgIGlmICh1cGRhdGVWYWx1ZSAmJiB1cGRhdGVWYWx1ZS50aGVuICYmICFfaXNTZXR0bGVkUGFjdCh1cGRhdGVWYWx1ZSkpIHtcbiAgICAgICAgc3RhZ2UgPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGFjdCA9IG5ldyBfUGFjdCgpO1xuXG4gIHZhciByZWplY3QgPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgMik7XG5cbiAgKHN0YWdlID09PSAwID8gc2hvdWxkQ29udGludWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KSA6IHN0YWdlID09PSAxID8gcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkgOiB1cGRhdGVWYWx1ZS50aGVuKF9yZXN1bWVBZnRlclVwZGF0ZSkpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuICByZXR1cm4gcGFjdDtcblxuICBmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJCb2R5KHZhbHVlKSB7XG4gICAgcmVzdWx0ID0gdmFsdWU7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIHVwZGF0ZVZhbHVlID0gdXBkYXRlKCk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVZhbHVlICYmIHVwZGF0ZVZhbHVlLnRoZW4gJiYgIV9pc1NldHRsZWRQYWN0KHVwZGF0ZVZhbHVlKSkge1xuICAgICAgICAgIHVwZGF0ZVZhbHVlLnRoZW4oX3Jlc3VtZUFmdGVyVXBkYXRlKS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2hvdWxkQ29udGludWUgPSB0ZXN0KCk7XG5cbiAgICAgIGlmICghc2hvdWxkQ29udGludWUgfHwgX2lzU2V0dGxlZFBhY3Qoc2hvdWxkQ29udGludWUpICYmICFzaG91bGRDb250aW51ZS52KSB7XG4gICAgICAgIF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRDb250aW51ZS50aGVuKSB7XG4gICAgICAgIHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gYm9keSgpO1xuXG4gICAgICBpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICghcmVzdWx0IHx8ICFyZXN1bHQudGhlbik7XG5cbiAgICByZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZXN1bWVBZnRlclRlc3Qoc2hvdWxkQ29udGludWUpIHtcbiAgICBpZiAoc2hvdWxkQ29udGludWUpIHtcbiAgICAgIHJlc3VsdCA9IGJvZHkoKTtcblxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuICAgICAgICByZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bWVBZnRlckJvZHkocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZXN1bWVBZnRlclVwZGF0ZSgpIHtcbiAgICBpZiAoc2hvdWxkQ29udGludWUgPSB0ZXN0KCkpIHtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZS50aGVuKSB7XG4gICAgICAgIHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgQ3Vyc29yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3Vyc29yKHF1ZXJ5U2VsZWN0b3IpIHtcbiAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IgPSBxdWVyeVNlbGVjdG9yO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDdXJzb3IucHJvdG90eXBlO1xuXG4gIC8vIHB1YmxpYyBhc3luYyBuZXh0KCk6IFByb21pc2U8VD4ge1xuICAvL1xuICAvLyB9XG4gIC8vIHB1YmxpYyBuZXh0Q2h1bmsoKTogUHJvbWlzZTx7IGNodW5rSUQ6IENodW5rSUQsIHJlY29yZHM6IFRbXSB9PjtcbiAgX3Byb3RvLm9uZSA9IGZ1bmN0aW9uIG9uZSgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGVtcDMgPSBmdW5jdGlvbiBfdGVtcDMoKSB7XG4gICAgICAgIF90aGlzMi5fZG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVjb3JkID0gbnVsbDtcblxuICAgICAgdmFyIF90ZW1wNCA9IF9mb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIV90aGlzMi5xdWVyeVNlbGVjdG9yLmRvbmUgfHwgIXJlY29yZDtcbiAgICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90aGlzMi5xdWVyeVNlbGVjdG9yLm5leHQoKSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciByZWNvcmRzID0gX3JlZi5yZWNvcmRzO1xuICAgICAgICAgIHJlY29yZCA9IHJlY29yZHNbMF0gfHwgbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGVtcDQgJiYgX3RlbXA0LnRoZW4gPyBfdGVtcDQudGhlbihfdGVtcDMpIDogX3RlbXAzKF90ZW1wNCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFsbCA9IGZ1bmN0aW9uIGFsbCgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGVtcDcgPSBmdW5jdGlvbiBfdGVtcDcoKSB7XG4gICAgICAgIF90aGlzNC5fZG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBhbGxSZWNvcmRzO1xuICAgICAgfTtcblxuICAgICAgaWYgKF90aGlzNC5fZG9uZSkgdGhyb3cgbmV3IEVycm9yKCdDdXJzb3IgYWxyZWFkeSBjb21wbGV0ZScpO1xuICAgICAgdmFyIGFsbFJlY29yZHMgPSBbXTtcblxuICAgICAgdmFyIF90ZW1wOCA9IF9mb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIV90aGlzNC5xdWVyeVNlbGVjdG9yLmRvbmU7XG4gICAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGhpczQucXVlcnlTZWxlY3Rvci5uZXh0KCkpLnRoZW4oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgdmFyIHJlY29yZHMgPSBfcmVmMi5yZWNvcmRzO1xuICAgICAgICAgIGFsbFJlY29yZHMucHVzaC5hcHBseShhbGxSZWNvcmRzLCByZWNvcmRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGVtcDggJiYgX3RlbXA4LnRoZW4gPyBfdGVtcDgudGhlbihfdGVtcDcpIDogX3RlbXA3KF90ZW1wOCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShyZWR1Y2VyLCBpbml0aWFsVmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGVtcDExID0gZnVuY3Rpb24gX3RlbXAxMSgpIHtcbiAgICAgICAgX3RoaXM2Ll9kb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF9yZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBpZiAoX3RoaXM2Ll9kb25lKSB0aHJvdyBuZXcgRXJyb3IoJ0N1cnNvciBhbHJlYWR5IGNvbXBsZXRlJyk7XG4gICAgICB2YXIgX3Jlc3VsdCA9IGluaXRpYWxWYWx1ZTtcblxuICAgICAgdmFyIF90ZW1wMTIgPSBfZm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICFfdGhpczYucXVlcnlTZWxlY3Rvci5kb25lO1xuICAgICAgfSwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RoaXM2LnF1ZXJ5U2VsZWN0b3IubmV4dCgpKS50aGVuKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgIHZhciByZWNvcmRzID0gX3JlZjMucmVjb3JkcztcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHQgPSByZWR1Y2VyKF9yZXN1bHQsIHJlY29yZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RlbXAxMiAmJiBfdGVtcDEyLnRoZW4gPyBfdGVtcDEyLnRoZW4oX3RlbXAxMSkgOiBfdGVtcDExKF90ZW1wMTIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhDdXJzb3IsIFt7XG4gICAga2V5OiBcImRvbmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kb25lO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXJzb3I7XG59KCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBiYXNlZGlyLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHtcblx0ICBwYXRoOiBiYXNlZGlyLFxuXHQgIGV4cG9ydHM6IHt9LFxuXHQgIHJlcXVpcmU6IGZ1bmN0aW9uIChwYXRoLCBiYXNlKSB7XG4gICAgICByZXR1cm4gY29tbW9uanNSZXF1aXJlKCk7XG4gICAgfVxuXHR9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAoKSB7XG5cdHRocm93IG5ldyBFcnJvcignRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgQHJvbGx1cC9wbHVnaW4tY29tbW9uanMnKTtcbn1cblxudmFyIHJ1bnRpbWVfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgLyoqXG4gICAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKi9cbiAgdmFyIHJ1bnRpbWUgPSBmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gICAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIHVuZGVmaW5lZCQxOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cblxuICAgIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICAgIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICAgIGRlZmluZSh7fSwgXCJcIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG5cbiAgICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBnZW5lcmF0b3I7XG4gICAgfVxuXG4gICAgZXhwb3J0cy53cmFwID0gd3JhcDsgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gICAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gICAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gICAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAgIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gICAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gICAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuXG4gICAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICAgIGFyZzogZXJyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gICAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiOyAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gICAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuXG4gICAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gICAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gICAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuXG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cblxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAgIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG5cblxuICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4gICAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG5cbiAgICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICAgIH1cblxuICAgIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpOyAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAgIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG5cbiAgICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gICAgfTtcblxuICAgIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgICAgcmV0dXJuIGdlbkZ1bjtcbiAgICB9OyAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAgIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuXG5cbiAgICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX19hd2FpdDogYXJnXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgICB9IC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cblxuXG4gICAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICAgIH1cblxuICAgIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yOyAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gICAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG5cbiAgICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcbiAgICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfSAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcblxuXG4gICAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkOyAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuXG4gICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gICAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gICAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG5cblxuICAgIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCQxKSB7XG4gICAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7IC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cblxuICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jOyAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIH0gLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG5cblxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9IC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gICAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuXG5cbiAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICAgIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpOyAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAgIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gICAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICAgIH07XG5cbiAgICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICAgIH1dO1xuICAgICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXlzLnJldmVyc2UoKTsgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcblxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuXG5cbiAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG5cbiAgICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBkb25lUmVzdWx0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gICAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQkMSxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0ID0gMDsgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cblxuICAgICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH0sXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuXG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgICAgfSxcbiAgICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH07IC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuXG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH0oIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgIG1vZHVsZS5leHBvcnRzICk7XG5cbiAgdHJ5IHtcbiAgICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAgIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gICAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gICAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gICAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gICAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gICAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAgIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAgIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRGaWVsZEJ5UGF0aChwYXRoKSB7XG4gIHZhciBwYXRoQXJyYXkgPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgdG1wID0gb2JqO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdG1wICE9PSAnb2JqZWN0JyB8fCAhdG1wKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGZpZWxkID0gcGF0aEFycmF5W2ldO1xuICAgICAgaWYgKGZpZWxkIGluIHRtcCkgdG1wID0gdG1wW2ZpZWxkXTtlbHNlIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcbn1cblxuLyoqXHJcbiAqINCU0L7RgdGC0YPQv9C90YvQtSDQvtC/0LXRgNCw0YLQvtGA0YtcclxuICogaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvXHJcbiAqL1xuXG52YXIgUXVlcnlPcGVyYXRvcnMgPSB7XG4gICRlcTogZnVuY3Rpb24gJGVxKGNvbmRpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gY29uZGl0aW9uO1xuICAgIH07XG4gIH0sXG4gICRndDogZnVuY3Rpb24gJGd0KGNvbmRpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IGNvbmRpdGlvbjtcbiAgICB9O1xuICB9LFxuICAkZ3RlOiBmdW5jdGlvbiAkZ3RlKGNvbmRpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBjb25kaXRpb247XG4gICAgfTtcbiAgfSxcbiAgJGx0OiBmdW5jdGlvbiAkbHQoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgY29uZGl0aW9uO1xuICAgIH07XG4gIH0sXG4gICRsdGU6IGZ1bmN0aW9uICRsdGUoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IGNvbmRpdGlvbjtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gYnVpbGRRdWVyeShxdWVyeSkge1xuICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKCdDb25kaXRpb25WYWxpZGF0b3IgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgdmFyIGJ5RmllbGRzID0gT2JqZWN0LmtleXMocXVlcnkpLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBnZXR0ZXIgPSBnZXRGaWVsZEJ5UGF0aChwYXRoKTtcbiAgICB2YXIgY29uZGl0aW9ucyA9IG1ha2VDb25kaXRpb25DaGVja2VyKHF1ZXJ5W3BhdGhdKTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICBjb25kaXRpb25zOiBjb25kaXRpb25zXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgcmV0dXJuIGJ5RmllbGRzLmV2ZXJ5KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gX3JlZi5nZXR0ZXIsXG4gICAgICAgICAgY29uZGl0aW9ucyA9IF9yZWYuY29uZGl0aW9ucztcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlcihyZWNvcmQpO1xuICAgICAgcmV0dXJuIGNvbmRpdGlvbnMuZXZlcnkoZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlQ29uZGl0aW9uQ2hlY2tlcihydWxlKSB7XG4gIHZhciBjb25kaXRpb24gPSB0eXBlb2YgcnVsZSA9PT0gJ29iamVjdCcgPyBydWxlIDoge1xuICAgICRlcTogcnVsZVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoY29uZGl0aW9uKS5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBhdHRyO1xuICAgIGlmICghKG9wZXJhdG9yIGluIFF1ZXJ5T3BlcmF0b3JzKSkgdGhyb3cgbmV3IEludmFsaWRRdWVyeUVycm9yKFwiVW5rbm93biBvcGVyYXRvciBcXFwiXCIgKyBvcGVyYXRvciArIFwiXFxcIlwiKTtcbiAgICByZXR1cm4gUXVlcnlPcGVyYXRvcnNbb3BlcmF0b3JdKGNvbmRpdGlvbltvcGVyYXRvcl0pO1xuICB9KTtcbn1cblxudmFyIEludmFsaWRRdWVyeUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW52YWxpZFF1ZXJ5RXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gSW52YWxpZFF1ZXJ5RXJyb3IobWVzc2FnZSwgcGF0aCwgcXVlcnkpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9FcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgX3RoaXMucGF0aCA9IHBhdGg7XG4gICAgX3RoaXMucXVlcnkgPSBxdWVyeTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZFF1ZXJ5RXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG52YXIgY2FsbFN5bWJvbCA9IFN5bWJvbCgnQ2FsbCcpO1xuZnVuY3Rpb24gY2FsbChhY3Rpb24pIHtcbiAgdmFyIF9yZWY7XG5cbiAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltjYWxsU3ltYm9sXSA9IHRydWUsIF9yZWYuYWN0aW9uID0gYWN0aW9uLCBfcmVmLmFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIF9yZWY7XG59XG5mdW5jdGlvbiBpc0NhbGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmICEhdmFsdWVbY2FsbFN5bWJvbF07XG59XG5cbnZhciBnZXRDaHVuayA9IGZ1bmN0aW9uIGdldENodW5rKGNodW5rSUQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RoaXMyLnN0b3JhZ2UubG9hZENodW5rKGNodW5rSUQpKS50aGVuKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgaWYgKCFjaHVuaykgdGhyb3cgbmV3IE5vdEZvdW5kQ2h1bmtFcnJvcihjaHVua0lEKTtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxufTtcblxudmFyIF9tYXJrZWQgPSAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZmluZEJydXRlRm9yY2UpO1xuZnVuY3Rpb24gZmluZEJydXRlRm9yY2UoaGVhZENodW5rSUQsIHF1ZXJ5KSB7XG4gIHZhciBtYXAsIGJ1aWx0UXVlcnksIGNodW5rLCBjaHVua0lELCByZWNvcmRzO1xuICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZmluZEJydXRlRm9yY2UkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBidWlsdFF1ZXJ5ID0gYnVpbGRRdWVyeShxdWVyeSk7XG4gICAgICAgICAgY2h1bmtJRCA9IGhlYWRDaHVua0lEO1xuXG4gICAgICAgIGNhc2UgNDpcblxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgIHJldHVybiBjYWxsKGdldENodW5rLCBjaHVua0lEKTtcblxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgY2h1bmsgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRDaHVua0Vycm9yKGNodW5rSUQpO1xuXG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmVjb3JkcyA9IG1hcFRvQXJyYXkoY2h1bmsucmVjb3JkcykuZmlsdGVyKGlzTmV3KG1hcCwgYnVpbHRRdWVyeSkpO1xuICAgICAgICAgIF9jb250ZXh0LnQwID0gY2h1bmsudHlwZTtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gX2NvbnRleHQudDAgPT09IENodW5rVHlwZS5TbmFwc2hvdCA/IDE0IDogX2NvbnRleHQudDAgPT09IENodW5rVHlwZS5UZW1wb3JhcnlUcmFuc2FjdGlvbiA/IDE2IDogX2NvbnRleHQudDAgPT09IENodW5rVHlwZS5JbmNyZW1lbnRhbCA/IDE2IDogMjA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgIGNodW5rSUQ6IGNodW5rSUQsXG4gICAgICAgICAgICByZWNvcmRzOiByZWNvcmRzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNodW5rSUQ6IGNodW5rSUQsXG4gICAgICAgICAgICByZWNvcmRzOiByZWNvcmRzXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIGNodW5rSUQgPSBjaHVuay5wYXJlbnRzWzBdO1xuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJicmVha1wiLCAyMSk7XG5cbiAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBjaHVuayB0eXBlIFxcXCJcIiArIGNodW5rLnR5cGUgKyBcIlxcXCJcIik7XG5cbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIF9tYXJrZWQpO1xufVxuXG5mdW5jdGlvbiBpc05ldyhtYXAsIGZpbHRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgIGlmIChtYXAuaGFzKHJlY29yZC5faWQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFmaWx0ZXIocmVjb3JkKSkgcmV0dXJuIGZhbHNlO1xuICAgIG1hcC5zZXQocmVjb3JkLl9pZCwgcmVjb3JkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXHJcbiAqINCe0YLQstC10YfQsNC10YIg0LfQsCDRgdC+0LfQtNCw0L3QuNC1INCy0YvQsdC+0YDQutC4INC00LvRjyDQutC+0L3QutGA0LXRgtC90L7Qs9C+INC/0YDQvtGB0YLRgNCw0L3RgdGC0LLQsCDQtNCw0L3QvdGL0YUg0L/QviDQutC+0L3QutGA0LXRgtC90L7QvNGDINC30LDQv9GA0L7RgdGDXHJcbiAqL1xuXG52YXIgUXVlcnlTZWxlY3RvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1ZXJ5U2VsZWN0b3IoZGIsIGNodW5rSUQsIHF1ZXJ5KSB7XG4gICAgdGhpcy5kYiA9IGRiO1xuICAgIHRoaXMuY2h1bmtJRCA9IGNodW5rSUQ7XG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLnNjZW5hcmlvID0gdGhpcy5kYi5ydW4oZmluZEJydXRlRm9yY2UodGhpcy5jaHVua0lELCB0aGlzLnF1ZXJ5KSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUXVlcnlTZWxlY3Rvci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGhpczIuc2NlbmFyaW8ubmV4dCgpKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBkb25lID0gX3JlZi5kb25lLFxuICAgICAgICAgICAgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgICAgICBfdGhpczIuX2RvbmUgPSAhIWRvbmU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFF1ZXJ5U2VsZWN0b3IsIFt7XG4gICAga2V5OiBcImRvbmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kb25lO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWVyeVNlbGVjdG9yO1xufSgpO1xuXG4vKipcclxuICog0KHQvtC30LTQsNC90LjQtSDQuCDQtNC+0L3QsNGB0YLRgNC+0LnQutCwINC30LDQv9GA0L7RgdCwINC6INCR0JRcclxuICovXG5cbnZhciBRdWVyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1ZXJ5KGRiLCBjaHVua0lELCBxdWVyeSkge1xuICAgIHRoaXMuZGIgPSBkYjtcbiAgICB0aGlzLmNodW5rSUQgPSBjaHVua0lEO1xuICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUXVlcnkucHJvdG90eXBlO1xuXG4gIF9wcm90by5leGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICB2YXIgcXVlcnlTZWxlY3RvciA9IG5ldyBRdWVyeVNlbGVjdG9yKHRoaXMuZGIsIHRoaXMuY2h1bmtJRCwgdGhpcy5fcXVlcnkpO1xuICAgIHJldHVybiBuZXcgQ3Vyc29yKHF1ZXJ5U2VsZWN0b3IpO1xuICB9O1xuXG4gIHJldHVybiBRdWVyeTtcbn0oKTtcblxuLyoqXHJcbiAqINCU0L7RgdGC0YPQvyDQuiDQtNCw0L3QvdGL0Lwg0LrQvtC90LrRgNC10YLQvdC+0Lkg0LrQvtC70LvQtdC60YbQuNC4INC4INC/0YDQvtGB0YLRgNCw0L3RgdGC0LLQsFxyXG4gKi9cblxudmFyIFNwYWNlUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3BhY2VSZWFkZXIoZGIsIHJlZnMsIGNvbmZpZykge1xuICAgIHRoaXMuZGIgPSBkYjtcbiAgICB0aGlzLnJlZnMgPSByZWZzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIGlmICghcmVmcykgdGhyb3cgbmV3IEVycm9yKFwiUmVmcyBjYW4gbm90IGJlIG51bGxcIik7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3BhY2VSZWFkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5maW5kID0gZnVuY3Rpb24gZmluZChxdWVyeSkge1xuICAgIHZhciBjaHVua0lEID0gdGhpcy5yZWZzW3RoaXMuY29uZmlnLm5hbWVdO1xuICAgIGlmICghY2h1bmtJRCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWYgXFxcIlwiICsgdGhpcy5yZWZzW3RoaXMuY29uZmlnLm5hbWVdICsgXCJcXFwiIGZvciBcIiArIHRoaXMuY29uZmlnLm5hbWUpO1xuICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5kYiwgY2h1bmtJRCwgcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5maW5kT25lID0gZnVuY3Rpb24gZmluZE9uZShxdWVyeSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGhpczIuZmluZEFsbChxdWVyeSkpLnRoZW4oZnVuY3Rpb24gKHJlY29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZHNbMF0gfHwgbnVsbDtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZChxdWVyeSkuZXhlYygpLmFsbCgpO1xuICB9O1xuXG4gIHJldHVybiBTcGFjZVJlYWRlcjtcbn0oKTtcblxudmFyIFRlbXBvcmFyeVRyYW5zYWN0aW9uQ2h1bmsgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdENodW5rKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRlbXBvcmFyeVRyYW5zYWN0aW9uQ2h1bmssIF9BYnN0cmFjdENodW5rKTtcblxuICBmdW5jdGlvbiBUZW1wb3JhcnlUcmFuc2FjdGlvbkNodW5rKGlkLCBwYXJlbnQsIHJlY29yZHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAocmVjb3JkcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZWNvcmRzID0gW107XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQWJzdHJhY3RDaHVuay5jYWxsKHRoaXMsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHR5cGU6IENodW5rVHlwZS5UZW1wb3JhcnlUcmFuc2FjdGlvbixcbiAgICAgIHBhcmVudHM6IHBhcmVudCA/IFtwYXJlbnRdIDogW10sXG4gICAgICByZWNvcmRzOiBhcnJheVRvT2JqZWN0KHJlY29yZHMpXG4gICAgfSkgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQ2h1bmtUeXBlLlRlbXBvcmFyeVRyYW5zYWN0aW9uO1xuICAgIF90aGlzLnJlY29yZHMgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFRlbXBvcmFyeVRyYW5zYWN0aW9uQ2h1bms7XG59KEFic3RyYWN0Q2h1bmspO1xuXG52YXIgQWNjZXNzb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBY2Nlc3NvcihkYiwgc3BhY2UpIHtcbiAgICB0aGlzLmRiID0gZGI7XG4gICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgIHRoaXMudXBkYXRlZFJlZnMgPSB7fTtcbiAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgZGVsZXRlZDogW10sXG4gICAgICBpbnNlcnRlZDogW10sXG4gICAgICB1cGRhdGVkOiBbXSxcbiAgICAgIHVwc2VydGVkOiBbXVxuICAgIH07XG4gICAgdGhpcy5jaHVua3MgPSB7fTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBY2Nlc3Nvci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERCID0gZnVuY3Rpb24gZ2V0REIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGI7XG4gIH07XG5cbiAgX3Byb3RvLmdldFNwYWNlID0gZnVuY3Rpb24gZ2V0U3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BhY2U7XG4gIH07XG5cbiAgX3Byb3RvLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHM7XG4gIH07XG5cbiAgX3Byb3RvLmNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjb2xsZWN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUmVhZGVyKHRoaXMuZGIsIHRoaXMucmVmcywgdGhpcy5kYi5jb2xsZWN0aW9uc1tuYW1lXS5jb25maWcpO1xuICB9O1xuXG4gIF9wcm90by5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQoY29sbGVjdGlvbiwgcmVjb3JkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBfdGhpczIud3JpdGVJbnRvQ29sbGVjdGlvbihjb2xsZWN0aW9uKTtcblxuICAgICAgaWYgKCFyZWNvcmQuX2lkKSByZWNvcmQgPSBfZXh0ZW5kcyh7fSwgcmVjb3JkLCB7XG4gICAgICAgIF9pZDogdXVpZC52NCgpXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMyLmNodW5rc1tjb2xsZWN0aW9uXS5yZWNvcmRzLnNldChyZWNvcmQuX2lkLCByZWNvcmQpO1xuXG4gICAgICBfdGhpczIuc3RhdHMuaW5zZXJ0ZWQucHVzaChyZWNvcmQuX2lkKTtcblxuICAgICAgX3RoaXMyLnN0YXRzLnVwc2VydGVkLnB1c2gocmVjb3JkLl9pZCk7XG5cbiAgICAgIF90aGlzMi5kYi5zdG9yYWdlLnNhdmVDaHVuayhfdGhpczIuY2h1bmtzW2NvbGxlY3Rpb25dKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWNvcmQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnVwc2VydCA9IGZ1bmN0aW9uIHVwc2VydChjb2xsZWN0aW9uLCByZWNvcmQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIF90aGlzNC53cml0ZUludG9Db2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuXG4gICAgICBpZiAoIV90aGlzNC5jaHVua3NbY29sbGVjdGlvbl0ucmVjb3Jkcy5oYXMocmVjb3JkLl9pZCkpIF90aGlzNC5zdGF0cy51cHNlcnRlZC5wdXNoKHJlY29yZC5faWQpO1xuXG4gICAgICBfdGhpczQuY2h1bmtzW2NvbGxlY3Rpb25dLnJlY29yZHMuc2V0KHJlY29yZC5faWQsIHJlY29yZCk7XG5cbiAgICAgIF90aGlzNC5kYi5zdG9yYWdlLnNhdmVDaHVuayhfdGhpczQuY2h1bmtzW2NvbGxlY3Rpb25dKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWNvcmQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLndyaXRlSW50b0NvbGxlY3Rpb24gPSBmdW5jdGlvbiB3cml0ZUludG9Db2xsZWN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoY29sbGVjdGlvbiBpbiB0aGlzLnVwZGF0ZWRSZWZzKSByZXR1cm47XG4gICAgdmFyIGNodW5rSUQgPSB1dWlkLnY0KCk7XG4gICAgdmFyIGNodW5rID0gbmV3IFRlbXBvcmFyeVRyYW5zYWN0aW9uQ2h1bmsoY2h1bmtJRCwgdGhpcy5yZWZzW2NvbGxlY3Rpb25dKTtcbiAgICB0aGlzLnVwZGF0ZWRSZWZzW2NvbGxlY3Rpb25dID0gY2h1bmtJRDtcbiAgICB0aGlzLmNodW5rc1tjb2xsZWN0aW9uXSA9IGNodW5rO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhBY2Nlc3NvciwgW3tcbiAgICBrZXk6IFwicmVmc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0aGlzLnNwYWNlLnJlZnMsIHRoaXMudXBkYXRlZFJlZnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBY2Nlc3Nvcjtcbn0oKTtcblxuLyoqXHJcbiAqINCf0YDQtdC00YHRgtCw0LLQu9GP0LXRgiDRgdC+0LHQvtC5INC00L7RgdGC0YPQvyDQuiDQvdCw0YHRgtGA0L7QudC60LDQvCDQuCDQtNCw0L3QvdGL0Lwg0LrQvtC70LvQtdC60YbQuNC4XHJcbiAqL1xuXG52YXIgQ29sbGVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbGxlY3Rpb24oZGIsIG5hbWUsIGNvbmZpZykge1xuICAgIHRoaXMuZGIgPSBkYjtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENvbGxlY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5zcGFjZSA9IGZ1bmN0aW9uIHNwYWNlKF9zcGFjZSkge1xuICAgIHZhciBzcGFjZUluc3RhbmNlID0gdGhpcy5kYi5zcGFjZXMuZ2V0KF9zcGFjZSk7IC8vIGNvbnNvbGUubG9nKHRoaXMuZGIuc3BhY2VzKVxuXG4gICAgaWYgKCFzcGFjZUluc3RhbmNlKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNwYWNlIFxcXCJcIiArIF9zcGFjZSArIFwiXFxcIlwiKTtcbiAgICByZXR1cm4gbmV3IFNwYWNlUmVhZGVyKHRoaXMuZGIsIHNwYWNlSW5zdGFuY2UucmVmcywgdGhpcy5jb25maWcpO1xuICB9O1xuXG4gIHJldHVybiBDb2xsZWN0aW9uO1xufSgpO1xuXG4oZnVuY3Rpb24gKFByaW9yaXR5KSB7XG4gIFByaW9yaXR5W1ByaW9yaXR5W1wiTG93XCJdID0gMV0gPSBcIkxvd1wiO1xuICBQcmlvcml0eVtQcmlvcml0eVtcIk5vcm1hbFwiXSA9IDJdID0gXCJOb3JtYWxcIjtcbiAgUHJpb3JpdHlbUHJpb3JpdHlbXCJIaWdoXCJdID0gM10gPSBcIkhpZ2hcIjtcbn0pKGV4cG9ydHMuUHJpb3JpdHkgfHwgKGV4cG9ydHMuUHJpb3JpdHkgPSB7fSkpO1xuXG52YXIgQ29sbGVjdGlvbkNvbmZpZyA9IGZ1bmN0aW9uIENvbGxlY3Rpb25Db25maWcobmFtZSwgY29uZmlnKSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuaW5kZXhlZEZpZWxkcyA9IFtdO1xuICB0aGlzLnByaW9yaXR5ID0gZXhwb3J0cy5Qcmlvcml0eS5Ob3JtYWw7XG4gIHRoaXMuaW5kZXhlZEZpZWxkcyA9IGNvbmZpZy5pbmRleGVkRmllbGRzIHx8IHRoaXMuaW5kZXhlZEZpZWxkcztcbiAgdGhpcy5wcmlvcml0eSA9IGNvbmZpZy5wcmlvcml0eSB8fCB0aGlzLnByaW9yaXR5O1xuICBpZiAoJ2ZhY3RvcnknIGluIGNvbmZpZykgdGhpcy5mYWN0b3J5ID0gY29uZmlnLmZhY3Rvcnk7ZWxzZSBpZiAoJ2NvbnN0cnVjdG9yJyBpbiBjb25maWcpIHRoaXMuZmFjdG9yeSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBjb25maWcuY29uc3RydWN0b3IoZGF0YSk7XG4gIH07ZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sbGVjdGlvbiBjb25maWcnKTtcbn07XG5cbnZhciBTcGFjZSA9IGZ1bmN0aW9uIFNwYWNlKGNvbmZpZykge1xuICB0aGlzLmlkID0gY29uZmlnLmlkO1xuICB0aGlzLm5hbWUgPSBjb25maWcubmFtZTtcbiAgdGhpcy5kZXNjcmlwdGlvbiA9IGNvbmZpZy5kZXNjcmlwdGlvbiB8fCAnJztcbiAgdGhpcy5yZWZzID0gY29uZmlnLnJlZnM7XG59O1xuXG52YXIgX2l0ZXJhdG9yU3ltYm9sID0gLyojX19QVVJFX18qL3R5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wuaXRlcmF0b3IgfHwgKFN5bWJvbC5pdGVyYXRvciA9IFN5bWJvbChcIlN5bWJvbC5pdGVyYXRvclwiKSkgOiBcIkBAaXRlcmF0b3JcIjtcblxuZnVuY3Rpb24gX3NldHRsZSQxKHBhY3QsIHN0YXRlLCB2YWx1ZSkge1xuICBpZiAoIXBhY3Qucykge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9QYWN0JDEpIHtcbiAgICAgIGlmICh2YWx1ZS5zKSB7XG4gICAgICAgIGlmIChzdGF0ZSAmIDEpIHtcbiAgICAgICAgICBzdGF0ZSA9IHZhbHVlLnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5vID0gX3NldHRsZSQxLmJpbmQobnVsbCwgcGFjdCwgc3RhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnRoZW4pIHtcbiAgICAgIHZhbHVlLnRoZW4oX3NldHRsZSQxLmJpbmQobnVsbCwgcGFjdCwgc3RhdGUpLCBfc2V0dGxlJDEuYmluZChudWxsLCBwYWN0LCAyKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFjdC5zID0gc3RhdGU7XG4gICAgcGFjdC52ID0gdmFsdWU7XG4gICAgdmFyIG9ic2VydmVyID0gcGFjdC5vO1xuXG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlcihwYWN0KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIF9QYWN0JDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfUGFjdCgpIHt9XG5cbiAgX1BhY3QucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IF9QYWN0KCk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBzdGF0ZSAmIDEgPyBvbkZ1bGZpbGxlZCA6IG9uUmVqZWN0ZWQ7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9zZXR0bGUkMShyZXN1bHQsIDEsIGNhbGxiYWNrKHRoaXMudikpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX3NldHRsZSQxKHJlc3VsdCwgMiwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy52O1xuXG4gICAgICAgIGlmIChfdGhpcy5zICYgMSkge1xuICAgICAgICAgIF9zZXR0bGUkMShyZXN1bHQsIDEsIG9uRnVsZmlsbGVkID8gb25GdWxmaWxsZWQodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICBfc2V0dGxlJDEocmVzdWx0LCAxLCBvblJlamVjdGVkKHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3NldHRsZSQxKHJlc3VsdCwgMiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF9zZXR0bGUkMShyZXN1bHQsIDIsIGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBfUGFjdDtcbn0oKTtcblxuZnVuY3Rpb24gX2lzU2V0dGxlZFBhY3QkMSh0aGVuYWJsZSkge1xuICByZXR1cm4gdGhlbmFibGUgaW5zdGFuY2VvZiBfUGFjdCQxICYmIHRoZW5hYmxlLnMgJiAxO1xufVxuXG5mdW5jdGlvbiBfZm9yVG8oYXJyYXksIGJvZHksIGNoZWNrKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBwYWN0LFxuICAgICAgcmVqZWN0O1xuXG4gIGZ1bmN0aW9uIF9jeWNsZShyZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKCsraSA8IGFycmF5Lmxlbmd0aCAmJiAoIWNoZWNrIHx8ICFjaGVjaygpKSkge1xuICAgICAgICByZXN1bHQgPSBib2R5KGkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICBpZiAoX2lzU2V0dGxlZFBhY3QkMShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQudjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4oX2N5Y2xlLCByZWplY3QgfHwgKHJlamVjdCA9IF9zZXR0bGUkMS5iaW5kKG51bGwsIHBhY3QgPSBuZXcgX1BhY3QkMSgpLCAyKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFjdCkge1xuICAgICAgICBfc2V0dGxlJDEocGFjdCwgMSwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhY3QgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX3NldHRsZSQxKHBhY3QgfHwgKHBhY3QgPSBuZXcgX1BhY3QkMSgpKSwgMiwgZSk7XG4gICAgfVxuICB9XG5cbiAgX2N5Y2xlKCk7XG5cbiAgcmV0dXJuIHBhY3Q7XG59XG5cbmZ1bmN0aW9uIF9mb3JPZih0YXJnZXQsIGJvZHksIGNoZWNrKSB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0W19pdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBfY3ljbGUgPSBmdW5jdGlvbiBfY3ljbGUocmVzdWx0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lICYmICghY2hlY2sgfHwgIWNoZWNrKCkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYm9keShzdGVwLnZhbHVlKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICAgIGlmIChfaXNTZXR0bGVkUGFjdCQxKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQudGhlbihfY3ljbGUsIHJlamVjdCB8fCAocmVqZWN0ID0gX3NldHRsZSQxLmJpbmQobnVsbCwgcGFjdCA9IG5ldyBfUGFjdCQxKCksIDIpKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFjdCkge1xuICAgICAgICAgIF9zZXR0bGUkMShwYWN0LCAxLCByZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhY3QgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX3NldHRsZSQxKHBhY3QgfHwgKHBhY3QgPSBuZXcgX1BhY3QkMSgpKSwgMiwgZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpdGVyYXRvciA9IHRhcmdldFtfaXRlcmF0b3JTeW1ib2xdKCksXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHBhY3QsXG4gICAgICAgIHJlamVjdDtcblxuICAgIF9jeWNsZSgpO1xuXG4gICAgaWYgKGl0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICB2YXIgX2ZpeHVwID0gZnVuY3Rpb24gX2ZpeHVwKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yW1wicmV0dXJuXCJdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChwYWN0ICYmIHBhY3QudGhlbikge1xuICAgICAgICByZXR1cm4gcGFjdC50aGVuKF9maXh1cCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBfZml4dXAoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfZml4dXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFjdDtcbiAgfSAvLyBObyBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3JcblxuXG4gIC8vIE5vIHN1cHBvcnQgZm9yIFN5bWJvbC5pdGVyYXRvclxuICBpZiAoIShcImxlbmd0aFwiIGluIHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTtcbiAgfSAvLyBIYW5kbGUgbGl2ZSBjb2xsZWN0aW9ucyBwcm9wZXJseVxuXG5cbiAgLy8gSGFuZGxlIGxpdmUgY29sbGVjdGlvbnMgcHJvcGVybHlcbiAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWVzLnB1c2godGFyZ2V0W2ldKTtcbiAgfVxuXG4gIHJldHVybiBfZm9yVG8odmFsdWVzLCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBib2R5KHZhbHVlc1tpXSk7XG4gIH0sIGNoZWNrKTtcbn1cblxuZnVuY3Rpb24gX2ZvciQxKHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuICB2YXIgc3RhZ2U7XG5cbiAgZm9yICg7Oykge1xuICAgIHZhciBzaG91bGRDb250aW51ZSA9IHRlc3QoKTtcblxuICAgIGlmIChfaXNTZXR0bGVkUGFjdCQxKHNob3VsZENvbnRpbnVlKSkge1xuICAgICAgc2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuICAgIH1cblxuICAgIGlmICghc2hvdWxkQ29udGludWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZENvbnRpbnVlLnRoZW4pIHtcbiAgICAgIHN0YWdlID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBib2R5KCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG4gICAgICBpZiAoX2lzU2V0dGxlZFBhY3QkMShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhZ2UgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB2YXIgdXBkYXRlVmFsdWUgPSB1cGRhdGUoKTtcblxuICAgICAgaWYgKHVwZGF0ZVZhbHVlICYmIHVwZGF0ZVZhbHVlLnRoZW4gJiYgIV9pc1NldHRsZWRQYWN0JDEodXBkYXRlVmFsdWUpKSB7XG4gICAgICAgIHN0YWdlID0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhY3QgPSBuZXcgX1BhY3QkMSgpO1xuXG4gIHZhciByZWplY3QgPSBfc2V0dGxlJDEuYmluZChudWxsLCBwYWN0LCAyKTtcblxuICAoc3RhZ2UgPT09IDAgPyBzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpIDogc3RhZ2UgPT09IDEgPyByZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KSA6IHVwZGF0ZVZhbHVlLnRoZW4oX3Jlc3VtZUFmdGVyVXBkYXRlKSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gIHJldHVybiBwYWN0O1xuXG4gIGZ1bmN0aW9uIF9yZXN1bWVBZnRlckJvZHkodmFsdWUpIHtcbiAgICByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGRvIHtcbiAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgdXBkYXRlVmFsdWUgPSB1cGRhdGUoKTtcblxuICAgICAgICBpZiAodXBkYXRlVmFsdWUgJiYgdXBkYXRlVmFsdWUudGhlbiAmJiAhX2lzU2V0dGxlZFBhY3QkMSh1cGRhdGVWYWx1ZSkpIHtcbiAgICAgICAgICB1cGRhdGVWYWx1ZS50aGVuKF9yZXN1bWVBZnRlclVwZGF0ZSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXG4gICAgICBpZiAoIXNob3VsZENvbnRpbnVlIHx8IF9pc1NldHRsZWRQYWN0JDEoc2hvdWxkQ29udGludWUpICYmICFzaG91bGRDb250aW51ZS52KSB7XG4gICAgICAgIF9zZXR0bGUkMShwYWN0LCAxLCByZXN1bHQpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZENvbnRpbnVlLnRoZW4pIHtcbiAgICAgICAgc2hvdWxkQ29udGludWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBib2R5KCk7XG5cbiAgICAgIGlmIChfaXNTZXR0bGVkUGFjdCQxKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnY7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXJlc3VsdCB8fCAhcmVzdWx0LnRoZW4pO1xuXG4gICAgcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gIH1cblxuICBmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKSB7XG4gICAgaWYgKHNob3VsZENvbnRpbnVlKSB7XG4gICAgICByZXN1bHQgPSBib2R5KCk7XG5cbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcbiAgICAgICAgcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdW1lQWZ0ZXJCb2R5KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zZXR0bGUkMShwYWN0LCAxLCByZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZXN1bWVBZnRlclVwZGF0ZSgpIHtcbiAgICBpZiAoc2hvdWxkQ29udGludWUgPSB0ZXN0KCkpIHtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZS50aGVuKSB7XG4gICAgICAgIHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3NldHRsZSQxKHBhY3QsIDEsIHJlc3VsdCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBDaHVua0RCID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2h1bmtEQihjb25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5zcGFjZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuYWN0aXZlVHJhbnNhY3Rpb25zID0gW107XG4gICAgdGhpcy5zdG9yZVN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB0aGlzLnNwYWNlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbGxlY3Rpb25zID0ge307XG4gICAgT2JqZWN0LmVudHJpZXMoY29uZmlnLmNvbGxlY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICAgICAgY2ZnID0gX3JlZlsxXTtcbiAgICAgIF90aGlzLmNvbGxlY3Rpb25zW25hbWVdID0gbmV3IENvbGxlY3Rpb24oX3RoaXMsIG5hbWUsIG5ldyBDb2xsZWN0aW9uQ29uZmlnKG5hbWUsIGNmZykpO1xuICAgIH0pO1xuICAgIHRoaXMuc3RvcmFnZURyaXZlciA9IGNvbmZpZy5zdG9yYWdlO1xuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBDaHVua1N0b3JhZ2UodGhpcy5zdG9yYWdlRHJpdmVyKTtcbiAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICBpZiAoY29uZmlnLnNwYWNlcykgY29uZmlnLnNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzcGFjZUlEKSB7XG4gICAgICBfdGhpcy5zcGFjZXMuc2V0KHNwYWNlSUQsIHtcbiAgICAgICAgaWQ6IHNwYWNlSUQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIHJlZnM6IHt9XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZXMucHVzaChfdGhpcy5zdG9yYWdlLmxvYWRTcGFjZShzcGFjZUlEKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zcGFjZXMuc2V0KHNwYWNlSUQsIG5ldyBTcGFjZShkYXRhKSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlYWR5JCA9IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaHVua0RCLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKHNwYWNlSUQsIGNiKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIHNwYWNlSUQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuc3RvcmVTdWJzY3JpcHRpb25zLnB1c2goc3BhY2VJRCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnN0b3JlU3Vic2NyaXB0aW9ucyA9IF90aGlzMi5zdG9yZVN1YnNjcmlwdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHNwYWNlSUQ7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdCA9IHRoaXMuc3BhY2VTdWJzY3JpcHRpb25zLmdldChzcGFjZUlEKSB8fCBbXTtcbiAgICBsaXN0LnB1c2goY2IpO1xuICAgIHRoaXMuc3BhY2VTdWJzY3JpcHRpb25zLnNldChzcGFjZUlELCBsaXN0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMi5zcGFjZVN1YnNjcmlwdGlvbnMuc2V0KHNwYWNlSUQsIGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBjYjtcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jb2xsZWN0aW9uID0gZnVuY3Rpb24gY29sbGVjdGlvbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5jb2xsZWN0aW9ucykgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNbbmFtZV07XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2xsZWN0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIik7XG4gIH07XG5cbiAgX3Byb3RvLnJ1biA9IGZ1bmN0aW9uIHJ1bihzY2VuYXJpbykge1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgc3RvcmFnZTogdGhpcy5zdG9yYWdlLFxuICAgICAgYWN0aXZlVHJhbnNhY3Rpb25zOiB0aGlzLmFjdGl2ZVRyYW5zYWN0aW9ucyxcbiAgICAgIHVwZGF0ZVNwYWNlUmVmczogdGhpcy51cGRhdGVTcGFjZVJlZnMsXG4gICAgICBzcGFjZXM6IHRoaXMuc3BhY2VzXG4gICAgfTtcbiAgICByZXR1cm4gc2NlbmFyaW9SdW5uZXIoY29udGV4dCwgc2NlbmFyaW8pOyAvLyBjb25zdCBnZW4gPSBzY2VuYXJpby5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAvL1xuICAgIC8vIGxldCByZXN1bHQ6IGFueTtcbiAgICAvL1xuICAgIC8vIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGdlbi5uZXh0KHJlc3VsdCk7XG4gICAgLy8gICAgIGlmIChkb25lKVxuICAgIC8vICAgICAgICAgcmV0dXJuIHZhbHVlIGFzIFQ7XG4gICAgLy9cbiAgICAvLyAgICAgY29uc3QgW2FjdGlvbiwgLi4uY2FsbEFyZ3NdID0gdmFsdWU7XG4gICAgLy9cbiAgICAvLyAgICAgcmVzdWx0ID0gYXdhaXQgYWN0aW9uLmFwcGx5KGNvbnRleHQsIGNhbGxBcmdzKTtcbiAgICAvLyB9XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zYWN0aW9uID0gZnVuY3Rpb24gdHJhbnNhY3Rpb24oc3BhY2VJRCwgbWF5YmVDb25maWcsIG1heWJlVHJhbnNhY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBzcGFjZSA9IF90aGlzNC5zcGFjZXMuZ2V0KHNwYWNlSUQpO1xuXG4gICAgICBpZiAoIXNwYWNlKSB0aHJvdyBuZXcgU3BhY2VOb3RGb3VuZEVycm9yKHNwYWNlSUQpO1xuICAgICAgdmFyIHRyYW5zYWN0aW9uO1xuICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgcmVzdGFydE9uRmFpbDogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXliZVRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gbWF5YmVUcmFuc2FjdGlvbjtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIG1heWJlQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gbWF5YmVDb25maWc7XG4gICAgICB9XG5cbiAgICAgIHZhciBhY2Nlc3NvciA9IG5ldyBBY2Nlc3NvcihfdGhpczQsIHNwYWNlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24oYWNjZXNzb3IpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LnVwZGF0ZVNwYWNlUmVmcyhzcGFjZUlELCBhY2Nlc3Nvci5yZWZzKTsgLy8gY29uc3QgZ2VuID0gdGhpcy5ydW4odGhpcy5hcHBseVRyYW5zYWN0aW9uKGFjY2Vzc29yKSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGdlbik7XG4gICAgICAgIC8vIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbi5uZXh0KCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgIC8vIGlmICghcmVzdWx0LmRvbmUpXG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgSW5uZXJEQkVycm9yKCdTY2VuYXJpbyBhcHBseVRyYW5zYWN0aW9uIG11c3QgcmV0dXJuIG9ubHkgb25lcycpO1xuXG5cbiAgICAgICAgcmV0dXJuIGFjY2Vzc29yLmdldFN0YXRzKCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRGbGF0Q2hhaW4gPSBmdW5jdGlvbiBnZXRGbGF0Q2hhaW4oaGVhZCwgbWF4RGVwdGgpIHtcbiAgICBpZiAobWF4RGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgbWF4RGVwdGggPSAzO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKCFtYXhEZXB0aCB8fCAhaGVhZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcbiAgICAgIHZhciBsYXN0Q2h1bmtzSWRzID0gW2hlYWRdO1xuICAgICAgdmFyIF9kZXB0aCA9IDA7XG5cbiAgICAgIHZhciBfdGVtcDQgPSBfZm9yJDEoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RlcHRoIDwgbWF4RGVwdGggJiYgISFsYXN0Q2h1bmtzSWRzLmxlbmd0aDtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kZXB0aCsrO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfdGVtcDIoKSB7XG4gICAgICAgICAgbGFzdENodW5rc0lkcyA9IGNodW5rc0lkcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVua3NJZHMgPSBbXTtcblxuICAgICAgICB2YXIgX3RlbXAgPSBfZm9yT2YobGFzdENodW5rc0lkcywgZnVuY3Rpb24gKGNodW5rSWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90aGlzNi5zdG9yYWdlLmxvYWRDaHVuayhjaHVua0lkKSkudGhlbihmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGNoYWluLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgY2h1bmtzSWRzLnB1c2guYXBwbHkoY2h1bmtzSWRzLCBjaHVuay5wYXJlbnRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIF90ZW1wICYmIF90ZW1wLnRoZW4gPyBfdGVtcC50aGVuKF90ZW1wMikgOiBfdGVtcDIoX3RlbXApO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RlbXA0ICYmIF90ZW1wNC50aGVuID8gX3RlbXA0LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICB9KSA6IGNoYWluKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGVTcGFjZVJlZnMgPSBmdW5jdGlvbiB1cGRhdGVTcGFjZVJlZnMoc3BhY2VJRCwgcmVmcykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgX3RoaXM4LnNwYWNlcy5zZXQoc3BhY2VJRCwgX2V4dGVuZHMoe30sIF90aGlzOC5zcGFjZXMuZ2V0KHNwYWNlSUQpLCB7XG4gICAgICAgIHJlZnM6IHJlZnNcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGhpczguc3RvcmFnZS5zYXZlU3BhY2UoX3RoaXM4LnNwYWNlcy5nZXQoc3BhY2VJRCkpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXJzID0gX3RoaXM4LnNwYWNlU3Vic2NyaXB0aW9ucy5nZXQoc3BhY2VJRCk7XG5cbiAgICAgICAgaWYgKHN1YnNjcmliZXJzKSBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENodW5rREI7XG59KCk7XG5cbmZ1bmN0aW9uIHNjZW5hcmlvUnVubmVyKGNvbnRleHQsIHNjZW5hcmlvKSB7XG4gIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dChyZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9leGl0MjtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfZm9yJDEoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIV9leGl0MjtcbiAgICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG1wID0gc2NlbmFyaW8ubmV4dChyZXN1bHQpO1xuICAgICAgICB2YXIgZG9uZSA9ICEhdG1wLmRvbmU7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRtcC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNDYWxsKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHZhbHVlLmFjdGlvbixcbiAgICAgICAgICAgICAgICBhcmdzID0gdmFsdWUuYXJncztcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWN0aW9uLmFwcGx5KGNvbnRleHQsIGFyZ3MpKS50aGVuKGZ1bmN0aW9uIChfYWN0aW9uJGFwcGx5KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IF9hY3Rpb24kYXBwbHk7XG5cbiAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBfZXhpdDIgPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBkb25lOiBkb25lLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfZXhpdDIgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuZXh0OiBuZXh0XG4gIH07XG59XG5cbnZhciBJbk1lbW9yeUNodW5rU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEluTWVtb3J5Q2h1bmtTdG9yYWdlKCkge1xuICAgIHRoaXMuY2h1bmtzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3BhY2VzID0gbmV3IE1hcCgpO1xuICB9IC8vIGNodW5rc1xuXG5cbiAgdmFyIF9wcm90byA9IEluTWVtb3J5Q2h1bmtTdG9yYWdlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubG9hZENodW5rID0gZnVuY3Rpb24gbG9hZENodW5rKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoX3RoaXMyLmNodW5rcy5oYXMoaWQpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90aGlzMi5jaHVua3MuZ2V0KGlkKSk7ZWxzZSB0aHJvdyBuZXcgTm90Rm91bmRDaHVua0Vycm9yKGlkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zYXZlQ2h1bmsgPSBmdW5jdGlvbiBzYXZlQ2h1bmsoY2h1bmspIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIF90aGlzNC5jaHVua3Muc2V0KGNodW5rLmlkLCBjaHVuayk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2h1bmspO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm1hcmtEcmFmdENodW5rQXNVbnVzZWQgPSBmdW5jdGlvbiBtYXJrRHJhZnRDaHVua0FzVW51c2VkKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBfdGhpczYuY2h1bmtzW1wiZGVsZXRlXCJdKGlkKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNldENodW5rcyA9IGZ1bmN0aW9uIHNldENodW5rcyhjaHVua3MpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgcmV0dXJuIF90aGlzNy5jaHVua3Muc2V0KGNodW5rLmlkLCBjaHVuayk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyQ2h1bmtzID0gZnVuY3Rpb24gY2xlYXJDaHVua3MoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICBfdGhpczkuY2h1bmtzLmNsZWFyKCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KGNodW5rcykge1xuICAgIHRoaXMuY2h1bmtzLmNsZWFyKCk7XG4gICAgdGhpcy5zZXRDaHVua3MoY2h1bmtzKTtcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlQ2h1bmsgPSBmdW5jdGlvbiByZW1vdmVDaHVuayhpZCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIF90aGlzMTEuY2h1bmtzW1wiZGVsZXRlXCJdKGlkKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH0gLy8gc3BhY2VzXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlU3BhY2UgPSBmdW5jdGlvbiBjcmVhdGVTcGFjZShzcGFjZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG5cbiAgICAgIGlmIChfdGhpczEzLnNwYWNlcy5oYXMoc3BhY2UuaWQpKSB0aHJvdyBuZXcgREJFcnJvcihcIkNhbiBub3QgY3JlYXRlIHNwYWNlIFxcXCJcIiArIHNwYWNlLmlkICsgXCJcXFwiOiBhbHJlYWR5IGV4aXN0c1wiKTtcblxuICAgICAgX3RoaXMxMy5zcGFjZXMuc2V0KHNwYWNlLmlkLCBzcGFjZSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRTcGFjZSA9IGZ1bmN0aW9uIGxvYWRTcGFjZShpZCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RoaXMxNS5zcGFjZXMuZ2V0KGlkKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2F2ZVNwYWNlID0gZnVuY3Rpb24gc2F2ZVNwYWNlKHNwYWNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpczE3ID0gdGhpcztcblxuICAgICAgX3RoaXMxNy5zcGFjZXMuc2V0KHNwYWNlLmlkLCBzcGFjZSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVNwYWNlID0gZnVuY3Rpb24gdXBkYXRlU3BhY2UoaWQsIHJlZnMpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzMTkgPSB0aGlzO1xuXG4gICAgICB2YXIgc3BhY2UgPSBfdGhpczE5LnNwYWNlcy5nZXQoaWQpO1xuXG4gICAgICBpZiAoIXNwYWNlKSB0aHJvdyBuZXcgREJFcnJvcihcIkNhbiBub3QgdXBkYXRlIHNwYWNlIFxcXCJcIiArIGlkICsgXCJcXFwiOiBub3QgZXhpc3RzXCIpO1xuXG4gICAgICBfdGhpczE5LnNwYWNlcy5zZXQoaWQsIF9leHRlbmRzKHt9LCBzcGFjZSwge1xuICAgICAgICByZWZzOiByZWZzXG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyU3BhY2VzID0gZnVuY3Rpb24gY2xlYXJTcGFjZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpczIxID0gdGhpcztcblxuICAgICAgX3RoaXMyMS5zcGFjZXMuY2xlYXIoKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldEFsbFNwYWNlcyA9IGZ1bmN0aW9uIGdldEFsbFNwYWNlcygpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzMjMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEFycmF5LmZyb20oX3RoaXMyMy5zcGFjZXMudmFsdWVzKCkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJbk1lbW9yeUNodW5rU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5DaHVua0RCID0gQ2h1bmtEQjtcbmV4cG9ydHMuQ29sbGVjdGlvbkNvbmZpZyA9IENvbGxlY3Rpb25Db25maWc7XG5leHBvcnRzLkluTWVtb3J5Q2h1bmtTdG9yYWdlID0gSW5NZW1vcnlDaHVua1N0b3JhZ2U7XG5leHBvcnRzLlNwYWNlID0gU3BhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../packages/core/dist/index.js\n");

/***/ })

});